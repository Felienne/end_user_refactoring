
\documentclass{sig-alternate}

%Deadline: April 8, 2015
%Call for papers: http://www.computer.org/web/computingnow/swcfp6

\usepackage{url}
\usepackage[table,xcdraw]{xcolor}
\usepackage{eurosym}
\usepackage{amsfonts}
\usepackage{balance}
\usepackage{cite} %this package is awesome - it reorders lists of citations to be in numeric order
\usepackage{pifont}
\usepackage{eqparbox}

% Tables
\usepackage{booktabs}
\usepackage{pbox}
\renewcommand{\arraystretch}{1.2} 
\usepackage{arydshln}
%\renewcommand*\cmidrule{} % No middle lines
%\renewcommand{\arraystretch}{1.5} % Additional spacing with no middle lines
%\renewcommand*\cmidrule{\hdashline[1pt/2pt]}% Dashed middle lines
\renewcommand*\cmidrule{\midrule[0.001em]} % Thin middle lines
%\renewcommand*\cmidrule{\midrule} % Thick middle lines

%Images
%\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

\hyphenation{second-ly ap-pen-dix}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ms}{LEGO MINDSTORMS EV3}
\newcommand{\mbs}{\textsc{my blocks}}
\newcommand{\mb}{\textsc{my block}}
\newcommand{\horiz}{\hspace{2.1pt}}

\newcommand{\ignore}[1]{}

\begin{document}
%\bstctlcite{IEEEexample:BSTcontrol}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{A Catalog of OO-inspired End-User Smells, \\and Application to \ms~and Kodu}
%\title{Perspectives on End-User Refactoring: Past, Present, and Future}

\numberofauthors{3}
\author{
% 1st. author
\alignauthor
Felienne Hermans\\
       \affaddr{Delft University of Technology}\\
       \affaddr{Mekelweg 4}\\
       \affaddr{Delft, the Netherlands}\\
       \email{f.f.j.hermans@tudelft.nl}
\alignauthor
Kathryn T. Stolee\\
       \affaddr{Department of Computer Science}\\
       \affaddr{Iowa State University}\\
       \affaddr{Ames, IA, U.S.A.}\\
       \email{kstolee@iastate.edu}
\alignauthor
David Hoepelman\\
       \affaddr{Delft University of Technology}\\
       \affaddr{Mekelweg 4}\\
       \affaddr{Delft, the Netherlands}\\
       \email{D.J.Hoepelman@tudelft.nl}
}
%\author{David Hoepelman, Katryn Stolee, Felienne Hermans}

\maketitle


\begin{abstract}
In the workforce today, millions of people program without degrees or professional training in software development. 
These end-user programmers perform a variety of tasks, from combining web information to building models to support business decisions. Software engineering research into code smells has traditionally focused on professionally used object-oriented programming languages, yet these end-user domains and languages also suffer from code smells. 

In this work, we explore recent research in two distinct end-user domains and languages: spreadsheets in Microsoft Excel and web mashups in Yahoo!\ Pipes. Based on existing OO-smells and their applications to these two end-user domains, we distill a catalog of generic end-user smells. 

We demonstrate the broad applicability of the catalog by applying it to two end-user languages not previously targeted by smell detection and refactoring research, both aimed at education: \ms~and Microsoft's Kodu. The results of this application show that indeed OO inspired smells occur in both end-user languages, most commonly we find that small abstractions, duplication and dead code are common. We conclude the paper by proposing new end-users smell, moving beyond the OO paradigm. 
\end{abstract}


\section{Introduction}
End-user programmers are said to outnumber  professional programmers three times over \cite{Scaf2005}.
These end-user programmers perform a wide variety of tasks within their organizations, ranging from creating new web streams to building and maintaining applications in a spreadsheet. While performing these tasks, end-user programmers face many of the challenges of professional developers, such as identifying faults, debugging, or understanding code written by someone else~\cite{Ko2011}.

Similar to code written by professional developers, end-user artifacts may have a long life-span, the average lifespan of a corporate spreadsheet being five years~\cite{Hermans2011}. During this long lifespan, end-user artifacts are modified, often by different people.
These properties make them, like source code artifacts, vulnerable to \emph{smells}. 

The taxonomy of smells outlined in Fowler's text pertained to object-oriented (OO) code, and professional programming languages were the focus for at least the first decade of refactoring and code smell research~\cite{Mens:2004:SSR:972215.972286}, but in the past few years, research has also been done into smells in end-user programming. Most notable are structural smells in Yahoo!\ Pipes web mashups~\cite{Stolee2011} and Excel spreadsheets \cite{Hermans2012inter}. Experiments in end-user areas have shown that end-user programmers understand smells, and often prefer versions of their code that are non-smelly \cite{Hermans2012intra, StoleeTSE2013, chambers2013smell}. 

% Related is also the work by Chambers and Scaffidi who study performance smells in LabView programming~\cite{chambers2013smell}.

In this paper we combine the two end-user smell approaches and obverse that many of the OO smells are applicable in both domains, either they have been already studied, or they could be. This led us to the introduction of a generically applicable, OO-inspired end-user smells. To demonstrate the broad applicability of the catalog, we applied it to two new end-user domains aimed at education: \ms~and Kodu. The results of the application show that OO inspired smells from our catalog in fact occur in both end-user languages, underlining the power of the code smells concept: they also apply on visual languages aimed at education, which are quite different from the textual languages aimed at professional developers that the concept was initially designed for. 

In EV3 and Kodu, the smells that we most commonly find are small abstractions (lazy class), duplication and dead code. In addition to the application of OO smells to the two new domains, we also move beyond the OO paradigm and hypothesize on domain specific smells for our four studied end-user languages: Excel, Yahoo! Pipes, EV3 and Kodu. The contributions of this work are as follows:

\begin{itemize}
	\item Synthesis and catalog of object-oriented-inspired code smells in end-user programs
	\item Application of the catalog to two new end-user domains focused on education: \ms~and Kodu
	\item Identification of future opportunities for domain-specific, non OO-inspired smell detection in end-user programming domains
\end{itemize}


\section{Background}
\label{sec:background}
In this section we briefly explore the two end-user languages targeted by prior smell research, before presenting the relevant end-user code smells in Section~\ref{sec:smells}.



\begin{figure}
\caption{Microsoft Excel 2013 showing a spreadsheet. Column B and C shows the typical mix of data and calculation. The formula of the selected cell B17 is visible right above the spreadsheet.}
\centering
\includegraphics[width=\columnwidth]{img/excel-2}
\label{fig:spreadsheetexample}
%file: fin_accounts from Euses / financial
\end{figure}

\noindent \textbf{Excel:} Spreadsheets are very commonly used in businesses, from inventory administration to educational applications and from scientific modeling to financial systems.
Winston ~\cite{Wins2001} estimates that 90\% of all analysts in industry perform calculations in spreadsheets. 
Microsoft Excel is by far the most used, and therefore most studied, spreadsheet program, but other implementations exists and are similar.

In modern spreadsheet programs, a \textit{cell} can contain a single \textit{formula} which performs a calculation, and a table of cells is bundled in a \textit{worksheet}; an example is shown in Figure~\ref{fig:spreadsheetexample}. 
A \textit{workbook} consist of a collection of worksheets.
Formulas can reference other cells in the same or in different workbooks and worksheets.


\noindent \textbf{Yahoo!\ Pipes:}
Yahoo!\ Pipes is a popular web mashup language and environment with which RSS feed information can be collected and combined from various sources.  Figure~\ref{fig:ypexample} shows an example program as it appears in the Pipes Editor. The boxes represent modules connected by wires and data flows from the data sources at the top  (e.g., \emph{Fetch Feed} modules) to the output at the bottom (i.e., \emph{Pipe Output}). Various manipulations of the data are possible along the  way, such as concatenating RSS feeds (e.g., \emph{Union} modules), sorting  or filtering based on various criteria, or truncating the list (e.g., \emph{Truncate} modules). 
Abstraction is possible with \emph{subpipe} modules, which allow a programmer to insert a different pipe as a subroutine. These subpipes appear like a standard module but when clicked, open a the abstracted pipe in an editor. 

\todo{Talk about how YP is being deprecated}

\begin{figure}
\caption{Example of a program in Yahoo!\ Pipes. It has five RSS feed data sources, each in a \emph{Fetch Feed} module, feeding to a \emph{Union} module that concatenates the feeds, a \emph{Truncate} module that limits the number of items to 15 prior to the final \emph{Pipe Output}. }
\centering
\includegraphics[width=\columnwidth]{img/yp-1}
\label{fig:ypexample}
\end{figure}


\section{Smells in end-user programs}
\label{sec:smells}
Research into end-user language smells has had two approaches, which are not mutually exclusive.
The first approach is to take existing smells for OO programming languages, usually those defined by Fowler~\cite{Fowl1999}, and transform them to be applicable to the end-user environment \cite{Hermans2012inter,Hermans2012intra,Stolee2011,StoleeTSE2013, chambers2013smell}.
The second approach is to define smells tailored to the end-user environment.
This can be done by interviewing experienced end-users to see which smells they perceive \cite{chambers2013smell}, by looking at user reports like forum or newsgroup posts~\cite{badame2012refactoring,chambers2013smell}, or by analyzing publicly available repositories \cite{Stolee2011,StoleeTSE2013,Hermans2012intra}.

This section provides an overview of different smells that researchers have found to be applicable to end-user artifacts using both the above described approaches and proposes future directions for smell detection in these domains. 

\begin{table*}
\caption{Catalog of Code Smells in End-User Programs
\label{table:oosmellslarge}}
\centering
\sffamily
\begin{tabular} {@{}llll@{}}
\toprule
\textbf{OO Smell}
	& \textbf{Excel}
	& \textbf{Yahoo!\ Pipes}
\\ \midrule
Dead Code
	& %~\ding{55}
	& Unnecessary Module \cite{StoleeTSE2013}
\\ \cmidrule
Duplicate Code
	& Duplicated Formulas \cite{Hermans2012intra}
	& Duplicate Modules, Duplicate String or
\\ % Continuation
& 
& Isomorphic Paths \cite{StoleeTSE2013}
\\ \cmidrule
Feature Envy
	& Feature Envy \cite{Hermans2012inter}
	& %Feature Envy *
\\ \cmidrule
Inappropriate Intimacy
	& Inappropriate Intimacy \cite{Hermans2012inter}
	& %Inappropriate Intimacy *
\\ \cmidrule
Lazy class or Middle Man
	& Middle Man \cite{Hermans2012inter}
	& Unnecessary Abstraction \cite{StoleeTSE2013}
\\ \cmidrule
Long Method
	& Multiple Operations \cite{Hermans2012intra}
	& Noisy Module : Duplicate Field \cite{StoleeTSE2013}
\\ \cmidrule
Many Parameters
	& Multiple References \cite{Hermans2012intra}
	& 
\\ \cmidrule
Message Chain
	& Long Calculation Chain \cite{Hermans2012intra}
	& 
\\ \cmidrule
No-op
	& %Redundant Operations *
	& Unnecessary Module \cite{StoleeTSE2013}
\\ \cmidrule
Unused Field
	& %~\ding{55}
	& Noisy Module : Empty Field \cite{StoleeTSE2013}
\\ \cmidrule
Use of Deprecated Interfaces
	& %Deprecated Functions *
	& Deprecated Module or Invalid Source \cite{StoleeTSE2013}
\\ \bottomrule
%\multicolumn{4}{c}{} \\
%\multicolumn{4}{l}{\ding{55} : Not applicable due to the nature of the paradigm} \\
%\multicolumn{4}{l}{* : Proposed smell, likely future opportunity not supported by prior work}\\
%\multicolumn{4}{l}{$\langle$blank$\rangle$ : Not discussed in this work, possible future opportunity} \\
%\multicolumn{4}{l}{\todo{fill all empty spots, they should either be explicitly NA or possible}} \\
\end{tabular}
\end{table*}



%\subsection{OO Smells in End-User Programs}
%\label{sec:smells:oo}
 We summarize the OO smells present in two end-user languages, Excel spreadsheets and Yahoo!\ Pipes mashups, in Table~\ref{table:oosmellslarge}.
 Overall, we often observe similarities in the code smells studied. For example, the \emph{Duplicate Code}, \emph{Lazy Class}, and \emph{Long Method} smells  have been studied in both languages. 
% \todo{is this a fair assesment?}
We note that the absence of an entry in Table~\ref{table:oosmellslarge} does not mean the absence of the smell in that language, it simply means such smells have not been studied. We speculate on a few of these opportunities in Section~\ref{subsec:futuresmells}. 

% Some smells, like the \emph{Long Method} smell, have been studied in only one domain but are likely applicable in the other domain, these are marked with *.  These smells present opportunities for future research, detailed in Section~\ref{subsec:futuresmells}.
 
% In this section we will detail the application of OO smells on specific end-user languages.
 
% A small number of smells are definitely not applicable (\ding{55}) because of differences in the domains. Spreadsheets, for example, cannot contain dead code because the user might still be interested in a piece of data even if it is not used anywhere else in the spreadsheet.

 \subsection{Excel}
Hermans et al. \cite{Hermans2012inter,Hermans2012intra} analogize a workbook to a program, a worksheet to a class inside that program and a cell to a method and use this to transform nine of Fowlers smells.
An example of this is the \emph{Long Method} smell, which translates to the \emph{Multiple Operations} smell because formulas with a large number of operations suffer from similar problems as long methods. In an industrial case study with 10 spreadsheet users, the smells were found understandable by users, and with the smells errors in real-life spreadsheets were found.

\subsection{Yahoo!\ Pipes}
Stolee and Elbaum~\cite{Stolee2011, StoleeTSE2013} treat a Yahoo!\ Pipes mashup as a class and each module as a method.  Fields in a module are treated as parameters. Using this analogy,  several OO smells were mapped to this language. The most common smell, appearing in nearly one-third of the 8,000 pipes studied, was \emph{Duplicate Strings}, an instance of Fowler's \emph{Duplicate Code} smell. 
\emph{Duplicate Modules}, impacted nearly one-quarter of the pipes studied. 
 Overall, 81\% of the programs studied from the Yahoo!\ Pipes community had at least one smell. 
 
Yahoo!\ can also \emph{deprecate modules}, which can create similar problems to using deprecated or old versions of interfaces.


\begin{figure} [ht]
\caption{The interface of \ms~showing a simple line following program.}
\centering
\includegraphics[width=\columnwidth]{img/ms}
\label{fig:ms}
\end{figure}

\subsection{Further Applications of OO smells}
\label{subsec:futuresmells}
Although not all OO smells have been studied in both domains, indicated by empty places in Table \ref{table:oosmellslarge}, this does not mean they do not apply. For example, Feature Envy is not discussed in previous work on Yahoo! Pipes, but could apply when \todo{Katie, how exactly?}. Similarly, redundant operations could occur in Excel, in fact, they do. A formula like SUM(A1+A2+A3), which we have seen in practice, exhibits the No-Op smell, as the SUM function does not add anything. While the occurrence of these smells falls outside of the scope of the current work, in this section we discuss the potential of generalizing some of the OO and domain-specific smell definitions to additional domains, thus addressing the empty places in Table \ref{table:oosmellslarge}.

\subsubsection{Excel}
Most of the smells studied in other end-user domains have been studied in Excel spreadsheets, but there is future potential in the areas of redundancy and deprecation. The \emph{Dead code} smell

Furthermore, research in smells and spreadsheets has focused on Microsoft Excel. However, other spreadsheet software exists and operates on the same principles. Thus there is also an opportunity to confirm that the identified smells apply in other spreadsheet software.

\subsubsection{Yahoo!\ Pipes}
\label{sec:smells:future:yp}
%Many of the smells studied in Excel and LabVIEW could apply to Yahoo!\ Pipes, and in particular, \emph{Feature Envy} and \emph{Inappropriate Intimacy}. 
%uses methods of another class excessively - envy
The \emph{Feature Envy} smell could  apply when introducing abstraction. For example, if a pipe has several instances of the same subpipe module, this could be excessive use of another class. 

%depends on implementation of another class too much - intimacy
When a program uses too much abstraction relative to the size of the pipe, it could suffer from \emph{Inappropriate Intimacy} by depending too much on the implementation of the other class. In fact, in an empirical evaluation, programmers often preferred pipes without subpipe modules because they were easier to understand~\cite{StoleeTSE2013}. 

%long method
A \emph{Long Module} smell could apply when a module has a large number of fields. For example, the \emph{Fetch Feed} module, as in Figure~\ref{fig:ypexample}, can hold one or more URLs. When the number of URLs makes the method so big it does not fit on the screen, this would likely impact the understandability of the pipe. 

Drawing inspiration from the domain-specific \emph{Inconsistent Formula} smell in Excel, identifying program patterns that are close, but not exactly the same, could identify missed opportunities for abstraction or errors in the mashup structure. 


%\subsubsection{Other Domains}
%End-user programming domains extend beyond spreadsheets and web mashupss. Stolee and Elbaum explore future opportunities for refactoring in educational programming languages~\cite{StoleeTSE2013}. \todo{revisit, this is a bit strange now this paper talks about education too}

%Other end-user programming domains that could benefit from smell analysis and refactoring are mathematical environments like MATLAB, Sage, and Mathematica.

%In particular, the smells related to duplication and poor construction like \emph{Long Method}, \emph{Many Parameters} and \emph{Dead Code} are prevalent in the four domains studied.
%These smells -- and their respective refactorings -- likely exist in other end-user programming domains, and likely hinder the understandability and maintainability of those programs. Worse even, these smells could lead to errors, and thus these smells are worthy of our attention. 

%\subsection{Future Opportunities in Professional Languages}
%In end-user programming languages, it has been shown that code smells impact the understandability of
%source code~\cite{StoleeTSE2013}. Additionally, being presented with code smells can motivate end-user programmers to improve their code~\cite{chambers2013smell}, and smells in spreadsheets have even been known to reveal actual errors~\cite{Hermans2012intra}. These lessons could extend to professional programming languages. but further study is needed. 
% outside of the end-user programming domains. 
%There has been successful in using automating smell detection, for example, during agile development (e.g.,~\cite{Schumacher:2010:BES:1852786.1852797}). Paired with the end-user evidence, a stronger case can be made to integrate automated smell detection in many domains. 

%\todo{Other data flow languages could benefit from \emph{normalize order of operations} to improve understandability (as it does with YP). }


\section{Application}
\label{sec:application}
In Section~\ref{sec:smells}, we distill a catalog of end-user smells from previous work. In order to demonstrate the applicability of our catalog, we apply it to two new domains: \ms~software (EV3 for short) and  Kodu. 

\subsection{\ms}
\ms~is the third iteration of the LEGO MINDSTORMS robotics line. It consists of a number of sensors, four motors and an ARM 9 ``intelligent brick''. The robotics kit comes with a control software package, which allows for visual programming of the brick. The software supports several basic constructs common to programming, including loops and conditionals, but also more advanced features like parallel execution. Figure \ref{fig:ms} shows the user interface of the EV3 software with a program that makes a robot follow a black line by steering left if the sensor value is below the threshold of 7 and right if the value is above, and in parallel writes the sensor value to the screen. Blocks have to be connected by wires, like the two coming from the `Play button' that acts as the starting point, to be executed. The program in Figure \ref{fig:ms} demonstrates some of the basic EV3 programming concepts including parallel execution, loops and switches.

In addition to the programming concepts described above, users have the possibility to define `\mbs' which basically are subroutines. \mbs~may have up to 9 different input and one output parameter. \mbs~cannot be programmed from scratch; they can only be created by selecting blocks in an existing program and creating a new block for them, together with a call to the newly created block, an action extremely similar to `extract method' present in most modern IDEs. 

\subsubsection{Smells  in \ms}
In this subsection we describe how the smells in our OO-inspired catalog apply to EV3 programs. As common in the other approaches, we define a loose mapping of OO concepts to the end-user language in question to be able to translate the smells. In EV3 programming, there are  \emph{\mbs~} that contain a number of blocks, can be used multiple times and can use input and output. As such they resemble methods in source code, modules in Yahoo! Pipes and worksheets in spreadsheets. Based on this translation, we investigate which of the smells in our catalog could apply to EV3 programs too. 

\begin{description}
\item[Dead Code] It is possible for programming blocks to be disconnected, but the interface clearly indicates this by making them gray \todo{added picture here?}. However, unused \mbs~can be present in the project without a warning being issued. This is smelly as it makes the program unnecessarily large.
\item[Deprecated Interfaces] This is a smell that does not apply, as, to date, there is only one version of the EV3 software and no blocks have been depreciated.
\item[Duplicate Code] When the same, or very similar combinations of blocks occur, this would be the duplicate code smell.
\item[Feature envy] While all defined variables within EV3 programs are global, they can be written in a certain \mb~but read in a different one. If, in a given \mb~many variables are read that have been written somewhere else, this might be an occurrence of the feature envy smell. 
\item[Inappropriate Intimacy] Variables might be read in one \mb~but written somewhere else. If there are two \mbs~sharing multiple variables this way, it might be better to combine them.
\item[Lazy Class] If a \mb~is very small, for example, consisting of just one block, they do not add a lot of value, while making the program harder to understand, as a user has to navigate to the \mb~to see what its function is.
\item[Long method] If a \mb~grows very large, it will no longer be easy to understand, counteracting the added value of the abstraction.
\item[Many Parameters] \mbs~can have 9 different parameters, which could be considered too much for easy understandability, especially since parameters need to be connected with wires, potentially leading to visual clutter in the case of many parameters.
\item[Message Chain] Because \mbs~can have both input and output parameters, it is possible that they created a message chain in which values are continuously passed until they are used, while they could have been passed outside of the \mbs~.
\item[No-op] It is possible to combine blocks in such a fashion that they do not actually contribute to the functionality of the program. For example, it a user stops the same motor twice, the second stop will be a no-op.
\item[Unused Field] As explained above, \mbs~can define parameters. However, the user is not forced to use them, hence it is possible to define more parameters than used.

\end{description}


\begin{figure} [ht]
\caption{Two blocks representing the same functionality, one in a regular block and one using a \mb.}
\centering
\includegraphics[width=3cm]{img/weg}
\label{fig:weg}
\end{figure}

\subsubsection{Study context}
To determine if EV3 programs indeed suffer form the above defined smells, we have gathered 17 programs from two data sources. The first source is robotics club ran by one of the authors of this paper. It is a club where kids aged 8 to 13 program robots every week. Their programs have been collected as dataset for this paper. More specifically, we focus on two different projects within this set, RoboCup and Sumo. These two types of programs related to two different LEGO MINDSTORMS competitions: Sumo is a simple robot game in which robots have to `sumo wrestle' each other: the robot that gets pushed out of the circular competition area first loses\footnote{\url{http://www.sugobot.com/}}. The Robocup programs were made to participate in the RoboCup Junior Rescue challenge\footnote{\url{http://rcj.robocup.org/rescue.html}}, where robots have to first navigate part of the field by following a line and subsequently look for a soda can and push it out of the field.

To obtain a more diverse set of EV3 programs, we have solicited members of the EV3 programming group on Facebook to share their programs with us\footnote{\url{https://www.facebook.com/groups/legomindstorms/permalink/527560164058881/}}.

\subsubsection{Findings}
When investigating the programs, we found that they indeed can suffer from OO-inspired smells. There are only two smells that do not occur in any of the programs: Inappropriate Intimacy and Message Chain. Duplicate Code occurs most, in over half of the programs. 

Table \ref{tab:robotica} presents an overview of the smells found in the EV3 programs.


\begin{figure} [ht]
\caption{The project properties screen for the Sumo program 1, showing the three \mbs~, but not indicating the \mb~`draaien' is currently not called from the main program.}
\centering
\includegraphics[width=\columnwidth]{img/overview}
\label{fig:overview}
\end{figure}

\paragraph{Duplicate Code}
The most common smell we found in the nine programs is the Duplicate Code smell, which 11 out of 17 programs suffer from. Duplication comes in various forms, some of the programs use two motor blocks in a row, that could have been merged, like the two blocks from program L17, shown in Figure \ref{fig:dup_ev3}. This might have been challenging for the users to detect, as they use two slight variations of the motor block, but the two behave exactly the same in this special case, where the direction is straight forward. Other programs exhibit duplication at a high level, like two \mbs~in program L16, depicted in Figure \ref{fig:dup_ev3_myblocks}. Here, the two \mbs~perform the exact same operation, but on a different motor. By connecting the name of the motor to a parameter two, this functionality could have been implemented with one \mb.

\begin{figure} [ht]
\caption{The duplication smell in two subsequent motor blocks. Since both have the same power and direction, they could have been merged. }
\centering
\includegraphics[width=\columnwidth]{img/dup_ev3}
\label{fig:dup_ev3}
\end{figure}

\begin{figure} [ht]
\caption{The duplication smell in two different \mbs. Both \mbs~turn a motor, and which motor could have been put in a parameter, like angle and speed already are. }
\centering
\includegraphics[width=\columnwidth]{img/dup_ev3_myblocks}
\label{fig:dup_ev3_myblocks}
\end{figure}

\paragraph{Dead Code}
The second most common smell is Dead Code. In seven out of 17 programs we found \mbs~that no longer connected to one of programs. This can pose a problem, as the EV3 environment compiles and transfers all programs and \mbs~to the brick, causing the memory to be full quite quickly. We see that Dead Code is more common in the robotics class programs than in the programs we received via Facebook. This is probably due to the fact that these users felt confident enough to share their programs, because either the programs were reviewed before sharing them, or the experience users selected `nice' programs to share.

Looking at the EV3 programming interface, it is not that surprising that users forget about disconnected \mbs. The interface does not help users in understanding what \mbs~are used. If we look at the project properties screen, shown in Figure \ref{fig:overview}, one can see that there is no information about which \mb~is used where. Even worse, user can delete \mbs~that are still being called, without a warning being issued about this. After removal of a \mb~ in use, the program no longer compiles.

\begin{table*}[]
\centering

\caption{Size in terms of the different number of blocks used in the seventeen \ms~programs, and the smells they exhibit \todo{deprecated interfaces?}}
\label{tab:robotica}
\sffamily
\begin{small}
\begin{tabular}{l|lllll|lll|lllllllll}
Name & L1  & L2 & L3  & L4  & L5  & L6  & L7  & L8  & L9  & L10 & L11 & L12 & L13 & L14 & L15 & L16 & L17 \\
\hline
Data         & 1  & 0  & 2  & 5  & 0  & 0  & 4  & 4  & 1  & 0  & 0 & 2  & 0  & 7  & 1 & 1  & 0   \\
Actor        & 8  & 6  & 5  & 7  & 16 & 8  & 10 & 16 & 10 & 1  & 2 & 1  & 7  & 15 & 2 & 2  & 78  \\
Sensor       & 1  & 0  & 0  & 2  & 1  & 0  & 8  & 10 & 4  & 1  & 0 & 1  & 0  & 4  & 2 & 0  & 0   \\
Logic        & 3  & 5  & 4  & 4  & 4  & 3  & 7  & 11 & 2  & 2  & 1 & 4  & 11 & 2  & 0 & 0  & 25  \\
MyBlock Call & 2  & 0  & 2  & 2  & 3  & 4  & 3  & 5  & 0  & 1  & 0 & 1  & 0  & 3  & 1 & 4  & 27  \\
Comment      & 2  & 0  & 0  & 1  & 0  & 0  & 1  & 0  & 0  & 6  & 6 & 0  & 15 & 0  & 0 & 7  & 13  \\
Variables    & 0  & 0  & 1  & 3  & 1  & 1  & 0  & 0  & 0  & 0  & 0 & 0  & 0  & 19 & 0 & 0  & 0   \\
MyBlocks     & 3  & 0  & 3  & 2  & 3  & 2  & 2  & 4  & 0  & 1  & 0 & 1  & 0  & 4  & 1 & 3  & 6   \\
\hline
Total        & 20 & 11 & 17 & 26 & 28 & 18 & 35 & 50 & 17 & 12 & 9 & 10 & 33 & 54 & 7 & 17 & 149\\
\hline
\hline
Dead Code                                              & \ding{51} &  & \ding{51} & \ding{51} &   &   & \ding{51} & \ding{51} &   &   &   &   &   & \ding{51} &   &   & \ding{51} \\
Deprecated                                          & --  & -- &  -- &--   &--   & --  & --  & --  &  -- & --  & --  & --  &  -- & --  & --  & --  & --  \\
Duplicate Code                                         &   &  &   & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} &   & \ding{51} &   &   & \ding{51} & \ding{51} \\
Feature Envy                                           & \ding{51} &  & \ding{51} & \ding{51} &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Inappropriate Intimacy                                 &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Lazy Class                                             & \ding{51} &  & \ding{51} & \ding{51} &   & \ding{51} &   &   &   &   &   &   &   &   &   &   &   \\
Long method                                            &   &  &   &   & \ding{51} &   &   &   &   & \ding{51} &   &   &   & \ding{51} &   &   & \ding{51}   \\
Many Parameters                                        &   &  &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &   &   &   \\
Message Chain                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
No-op                                                  &   &  & \ding{51} &   &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &  \\
Unused Field                                           &   &  &   & \ding{51} &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &   \\
\hline
Total Smells & 3 & 0 & 4 & 5 & 2 & 2 & 2 & 2 & 1 & 2 & 1 & 1 & 1 & 4 & 0 & 1 & 3
\\
\end{tabular}
\end{small}
\end{table*}


\paragraph{Lazy Class}
Lazy classes, which we counted as \mbs~containing three or fewer blocks, are also relatively common, occurring in four of the programs. However, we only find this smell in the programs from the robotics club and not in the programs received via Facebook. Many of `lazy \mbs'~were relatively small, consisting of two or three blocks, or even one in some cases. You could say this is smelly, as understanding the \mb~requires clicking it and that might not be worth it for small \mbs. However, the EV3 programming interface does not allow regular blocks to be named, but it does allow this for \mbs. So by making a \mb, users can express the intent of a coherent set of blocks, even if this set consist of just one block. 

As an example, consider the two blocks shown in Figure 5, where the upper one is regular block controlling a motor, while the lower one is a call to a \mb~with the same functionality. The first one just expresses what the robot must do, but the second one expresses the intent (`weg' meaning flee). By using the \mb, even with one block, the program gets easier to read.

\paragraph{Long method}
Long Method \todo{add threshold here} too occurs in four programs, but, contrary to Lazy Class, is found mostly in the Facebook programs. This is to be expected, more experienced users can handle bigger \mbs, while the kids from the robotics club stick with making small blocks.

\subsubsection{Summary}
To summarize, we again observe that smells stemming from OO are applicable to end-user domain: duplicate code, dead code and small abstractions seem to be anti-patterns that occur in programming in general, independent of the programming language. It is remarkable to see that even in a visual language, quite different from the textual, high-level languages for which the smells were originally designed, the same smells occur.


\subsection{Kodu}
Microsoft Research's Kodu is a visual programming language~\cite{kodugrammar} and environment that allows users to create, play, and share their own video games. 
It is available for download on the Xbox and PC and is heavily inspired by robotics, and the context of programming in it and its language both show this. 
Users can program each character or object (e.g., a kodu, cycle, apple, tree; we use character and object interchangeably) individually, and the programming defines how to interact with the world. Each object has 12 pages that can be programmed, analogous to methods in an OO language, where the current page defines the current behavior of the object. 
The object's behavior can change by switching between pages to modify state and control flow. 
Each page contains a set of rules, and each rule is in the form of a condition and an action, which form a when~--~do clause. The \emph{when} is defined by a sensor (e.g., see, hear, gamepad input) and filters (e.g., apple, gamepad A button). The \emph{do} is defined by an actuator (e.g., movement, shoot) and modifiers (e.g., missile, toward). All the rules on a page are evaluated in a single frame, from top to bottom. 
Despite its unique language, Kodu  can be used to express many basic concepts in computer science, such as variables, boolean logic and conditional control flow~\cite{Stolee:2011:ECS:1953163.1953197}. 

Figure~\ref{fig:Kodu} shows a page and two rules  in Kodu. For the first rule, the condition is, when see red apple, and the action is, move toward it. The action defines the behavior of this particular character when it sees a red apple, that is, it moves toward it. Since the condition identifies an object (i.e., apple), it becomes the default selector, even though it is not explicitly specified. The second rule has a similar condition with a different sensor, bump. The action of the second rule, eat, indicates that the character should eat any red apple it bumps. 
Rules can also be indented to create complex \emph{when} clauses, where both conditions need to be true for the action to occur. Alternatively, indenting a rule and removing the \emph{when} means that multiple \emph{do} clauses occur for the same trigger condition. 
The programming in Figure~\ref{fig:Kodu} applies to the first page in this character's programming, as indicated by the number one at the top of the screen. The first page is the default start page.


\begin{figure}[ht]
\caption{The interface of Kodu~showing programming behavior for a bot.}
\centering
\includegraphics[width=\columnwidth]{programmingui.png}
\label{fig:Kodu}
\end{figure}



\subsubsection{Smells in Kodu}
We describe how the smells in our OO-inspired catalog apply to Kodu programs. We define a loose mapping of the OO concepts to the end-user language. We consider pages of programming as analogous to methods or classes, similar to how modules are treated in Yahoo!\ Pipes, worksheets in spreadsheets and \mbs~in \ms. 

\begin{description}
\item[Dead Code] If there exists a page with programming such that there is no explicit path of control flow from Page~1 to it, it is unreachable and therefore dead. 
\item[Deprecated Interfaces] Some language features and bots may exist in early versions of Kodu but not be available in future versions. use of these deprecated entities may cause unexpected behavior when running an old program in a new environment and be smelly. 
\item[Duplicate Code] Two pages for the same character with exactly the same set of rules, or two identical rules on a page constitute duplicate code. Alternatively, two rules on the same page with the same \emph{when} clauses (i.e., sensor and filter) but different actions could be consolidated using the indent feature and thus are smelly. 
\item[Feature envy] All global variables, such as game scores, can be read and written by any character. If a certain character reads variables that have been written by another character, this could be an instance of the feature envy smell. 
\item[Inappropriate Intimacy] A character has four local properties that describe its state: color, glow color, expressions (angry, crazy, happy). If one character frequently checks the properties of another character, this could constitute inappropriate intimacy. 
\item[Lazy Class] If a character has no programming, it could be an instance of the lazy smell. 
%Characters with no programming are different than objects. Characters can have movement whereas objects cannot. 
\item[Long method] A page with many, many rules may be difficult to understand. Some programming could potentially move to other pages or other characters. We counted long methods as those with more than five rules. 
\item[Many Parameters] A game can have 37 different global scores. Games that use many of these could be unnecessarily smelly. 
\item[Message Chain] It is possible for a character to create a chain of switches between pages without any logic on the page other than the jump. This would create a long and unnecessary message chain. 
\item[No-op] Jumping to a page with no logic is the logical equivalent of a null pointer. While no error would be raised, the character would no longer have any behavior and would be stuck in that state. Alternatively, rules with \emph{when} clauses but no \emph{do} clauses do not perform any actions. 
\item[Unused Field] A global variable that is written to but not read is an instance of the the unused field smell. 

%\todo{emailed scoy at Microsoft about this}
\end{description}



\begin{table*}[]
\centering

\caption{Size in terms of the different number of characters and rules used in the 17 Kodu programs, and the smells they exhibit}
\label{tab:koduanalysis}
\sffamily
\begin{small}
\begin{tabular}{l | r@{\horiz }r@{\horiz }r@{ \horiz}r@{ \horiz}r@{\horiz }r@{ \horiz}r@{\horiz }r@{\horiz }r@{ \horiz}r@{ \horiz}r@{ \horiz}r@{\horiz }r@{\horiz }r@{ \horiz}r@{\horiz }r@{ \horiz}r@{\horiz } | r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r}
Name & K1  & K2 & K3  & K4  & K5  & K6  & K7  & K8  & K9  & K10 & K11 & K12 & K13 & K14 & K15 & K16 & K17 & K18 & K19 & K20 & K21 & K22 & K23 & K24 & K25 & K26 & K27\\
\hline
Characters        & 6&17&39&21&62&60&85&26&26&60&42&45&57&36&5&15&28
&28&10&2&16&18&76&75&63&4&76
\\
Pages 		&11&7&26&19&18&47&82&19&10&60&41&31&10&9&6&7&7
&34&16&2&39&18&9&50&90&8&78
\\
Rules 		&21&17&60&28&31&96&93&29&20&120&58&63&22&35&14&18&23
&114&54&3&113&27&30&122&144&32&372
\\
%Tiles        	& 90&64&252&150&121&418&535&141&66&227&230&244&81&159&54&90&103\\
HCI Actors & 1&2&1&1&2&1&1&1&1&1&1&1&1&0&2&1&1
& 5 & 1 & 0 & 0 & 1 & 1 & 1 & 37 & 0 & 2
\\
%\hline
%Total        & 20 & 11 & 17 & 26 & 28 & 18 & 35 & 50 & 17 & 12 & 9 & 10 & 33 & 54 & 7 & 17 & 149\\
\hline
\hline
Dead Code                                              &   &  &   &   &   &   &   &   &   &   &   &   &  \ding{51} &   &   &   &   
& & & & & & & \ding{51} & \ding{51} & &
\\
Deprecated                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   
& & & & & & &  & & & 
\\
Duplicate Code                                        &   &  & \ding{51}  &   &   & \ding{51}  & \ding{51}  & \ding{51}  & \ding{51}  &   &   & \ding{51}  &\ding{51}   & \ding{51}  &   & \ding{51}  &   
& \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & & \ding{51} & \ding{51} & & \ding{51}
\\
Feature Envy                                         &   &  & \ding{51}  &   &   &   &   &   &   & \ding{51}  &   &   &   &   &   &   &   
&  &  \ding{51}& & & & & \ding{51} & \ding{51} & & \ding{51}
\\
Inapprop. Int.                            &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &  \ding{51} &   
& & & & & & & & & &
\\
Lazy Class                                             &   & \ding{51} & \ding{51}  & \ding{51}  & \ding{51}  &\ding{51}   &\ding{51}   &\ding{51}   &\ding{51}   &   & \ding{51}  & \ding{51}  & \ding{51}  & \ding{51}  & \ding{51}  &  \ding{51} &\ding{51}   
& \ding{51} & & \ding{51} & \ding{51} & &  \ding{51}&  \ding{51}&  \ding{51}& & \ding{51}
\\
Long method                                        &  &  &  &   &   &\ding{51}   & &   & &   &   & \ding{51}  & \ding{51}  &   &   &   &    
&  \ding{51}& \ding{51} & & & & & \ding{51} & & & \ding{51}
\\
Many Params                                        &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   
& & & & & & &  &  & & \ding{51}
\\
Message Chain                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   
& & & & & & & \ding{51} & & &
\\
No-op                                                  &   & \ding{51} &   &   &   &   &   &   &   & \ding{51}  &   & \ding{51}  & \ding{51}  & \ding{51}  &   &   &\ding{51}   
& & \ding{51} & \ding{51} & & & &  \ding{51}&  \ding{51}& & \ding{51}
\\
Unused Field                                           &   &  &  \ding{51} &   &   &   &   &   & \ding{51}  &   &   & \ding{51}  &   &   & \ding{51}  &   &   
&  \ding{51}& & & & & & & \ding{51} & & \ding{51}
\\
\hline
Total Smells & 0 & 2 & 4 & 1 & 1 & 3 & 2 & 2 & 3 & 2 & 1 & 5 & 5 & 3 & 2 & 3 & 2 
& 4&4 &3 &2 &1 &1 &7 &6 &0 &7
\\

\end{tabular}
\end{small}
\end{table*}


\subsubsection{Study Context}
To determine if Kodu programs indeed suffer form the above defined smells, we have gathered  programs from two data sources. 
For the first data source, we ran a workshop at the Microsoft FUSE lab that introduced children to Kodu Game Lab in a series of three 3-hour sessions.  To recruit participants, we advertised the Kodu workshop using a mailing list of parents interested in Kodu.  
Children between the ages of 9 and 12 volunteered to participate, with parental consent. We collected 17 programs created during the workshop for analysis. 
For the second data source, we randomly sampled 10 programs from the public Xbox Live community. No demographic information was collected about the users. 

The programs were analyzed by hand by one of the authors. Table~\ref{tab:koduanalysis} presents the 17 programs created by children (K1 \dots K17), 10 programs created by the Xbox Live community (K18 \dots K27), and the smells found in each. The \emph{Characters} row defines how many characters and actors are in the program, \emph{Pages} defines how many pages of programming are used by the characters, \emph{Rules} counts all the rules on all the pages, and \emph{HCI Actors} counts the number of actors in the program that are controllable by the Xbox controller, mouse or keyboard. 
To count the number of instances of the \emph{long method}, a smell was counted when the page had 10 or more rules. For the  \emph{many parameters} smell, the use of four or more game scores. These thresholds were determined by the authors as 10 rules cannot be viewed on a screen screen without scrolling and only a couple games used more than three game scores. 

\subsubsection{Findings}
On average, the programs from children had 2.3 smells each and the programs from the community had 3.5 smells each, though we note that the programs from the community tend to be larger (e.g., an average of 101 rules vs. 42 rules). Next, we discuss the three most common smells found in the Kodu programs, appearing in 40\% or more of the sample. The remaining smells appear in 25\% or fewer programs. 

\subsubsection{Lazy class}
The lazy class smell was the most common, appearing in 79\% of the Kodu programs. This smell is intended to capture when a character is placed in the world but has no programming, and thus no behavior. In some cases, this may not be a smell at all, such as when characters are used as decorations in the world (e.g., trees and rocks). In others, it could be similar to an object that is created but that has no behavior. 

\subsubsection{Duplicate Code}
This smell was present in 61\% of the programs. All instances were that of duplicate \emph{when} clauses within a page, and there were no instances of identical rules on a page or identical pages within the same character. The prevalence of this feature shows a missed opportunity for consolidating the code. 

\subsubsection{No-op}
The next most-common smell is the no-op, present in 41\% of the programs. All instances of this smell were rules without \emph{do} clauses, rather than jumping to pages without logic. This is probably the product of the rapid cycling between testing and developing observed in Kodu development~\cite{Stolee:2011:ECS:1953163.1953197}; since the clauses have no actionable logic, keeping them in the code does not impact the semantics of the program. 

\subsection{Summary}
Table~\ref{tab:smellsummary} summarizes the frequencies of occurrence of the various smells in the  EV3 and Kodu programs. Overall, 88\% of the EV3 and 93\% of the Kodu programs contained at least one smell. Coupled with the 81\% of Yahoo!\ Pipes programs~\cite{StoleeTSE2013} and \todo{X\% of Excel programs} that were previously found to be smelly, this provides further evidence of the prevalence of smells in end-user programs. 

As with code written by other end-user programmers~\cite{StoleeTSE2013}, duplication smells are prevalent in EV3 and Kodu programs, affecting over 60\% of the samples in both languages. Dead code is more frequently found in EV3 and lazy classes are more common in Kodu. Long methods are found in approximately 25\% of the programs in both languages, and \todo{Y\% of the Excel programs}, showing that this smell, too, is common across languages. Feature envy was also prevalent across both languages, appearing in 18\% and 22\% of the EV3 and Kodu programs, respectively. 


\begin{table}
\caption{Summary of Smells Across EV3 and Kodu Programs \label{tab:smellsummary}}
\begin{center}
\begin{tabular}{l | r r}
&EV3&Kodu\\ \hline
Dead Code&41\%&11\%\\
Deprecated Interfaces & -- & 0\%\\
Duplicate Code&65\%&61\%\\
Feature Envy&18\%&22\%\\
Inappropriate Intimacy&0\%&4\%\\
Lazy Class&24\%&79\%\\
Long method&24\%&25\%\\
Many Parameters&6\%&4\%\\
Message Chain&0\%&4\%\\
No-op&12\%&41\%\\
Unused Field&12\%&25\%\\ \hline
Any smell & 88\% & 93\%
\end{tabular}
\end{center}
\end{table}

\section{Beyond OO Smells}
\label{sec:beyond}

\label{sec:smells:domain}
The end-user programming environments offer many opportunities to define smells based on user behavior or unique elements of the domain. Here, we explore opportunities for new smells in end-user domains that extend beyond the OO-inspired smells in Section~\ref{sec:smells}. 

\subsection{Excel}
In spreadsheets, data is often processed by having each record in a row and having a column with identical formulas to perform some calculation.
This leads to the definition of the \emph{Inconsistent Formula} smell, which occurs if a single, or small number, of cells contain a different formula while its neighbors or other cells in the row or column contain an identical formula.
Interestingly this smell is already detected by Microsoft Excel which warns the user about it.

Another smell specific to spreadsheets is when a formula references an empty cell, which is often in error \cite{cunha2012towards}.
This is comparable to a null pointer in other languages and would be a runtime error, but because a spreadsheet contains both the input data and logic we can directly mark it as a smell.

\subsection{Yahoo!\ Pipes}
%Talk about smells unique to the domain
By exploring a large subset of the Yahoo!\ Pipes repository, Stolee and Elbaum identified a smell based on the presence of broken data sources~\cite{StoleeTSE2013}.
A reference to a broken data sources  is similar to opening a non-existing file, which would be a runtime exception or error in most professional languages.
Such exceptions are not in the Yahoo!\ Pipes language, which is the reason to mark it as a smell. 
%Talk about deriving smells from the community
Similar exploration was used to  identify common programming practices, marking deviations from those practices as smells. 
This is similar to identifying  smells  as anti-patterns  and could be extended to any language. 

\subsection{EV3}
\todo{Katie, please check if the following makes (enough) sense without knowing EV3, I am too deep in to be able to judge}
\subsubsection{Wrong motor or sensor mapping}
The \ms~programming language differs significantly from the other end-user domains, as EV3 programmers work with both software and hardware. While programming, users need to configure motor blocks to the right port, for example the blocks in Figure \ref{fig:dup_ev3} are controlling motors A and D. This means that, when a user has the wrong mental model of what motor is connected to what port, the program will not function as wanted. It appears users run into this issue too, as some of the programs we saw comment blocks where the mapping was described, in an effort to ensure proper mapping \todo{if room add example}.

%Not sure if we should add this, but I have the rule in class that you can only raise your hand to ask a question if you have checked the mapping. And it still goed wrong often. 

Hence a smell unique to the EV3 domain is a wrong mapping between the robot in reality and the motor and sensor blocks. 

\subsubsection{Layout smells}
The EV3 language is a visual language without an auto-layouting function, this means that, when users are making changes to their programs, often the layout can get messy. This also happens when a user creates a \mb, blocks that have been moved to the \mb~ are replaced by a call to the newly created \mb, but other than that the layout remains unchanged. So if a big \mb~is created the program will now have a big gap, making the program harder to read \todo{if room show example}. This, and other layout smells too are unique to visual languages where the layout is not modified by the environment.


\subsection{Kodu}

	\subsubsection{Visual smell}
	 - does not fit on the screen
	 
	\subsubsection{Lack of Comments}
	 - YP has no comments, not encouraged in interface

\section{Related Work}

\label{sec:related_work}
Related to the current research are efforts on code smells within traditional languages, starting with the work of Fowler\cite{Fowl1999}. His book gives an overview of code smells and corresponding refactorings. Recent efforts focused on the automatic identification of code smells by means of metrics. Marinescu~\cite{Mari2001} for instance, uses metrics to identify \emph{suspect} classes, those classes that might have design flaws. Lanza and Marinescu~\cite{Lanz06} explain this methodology in more detail. Alves \emph{et al.}~\cite{Alves2010} focus on a strategy to obtain thresholds for metrics from a benchmark. Olbrich \emph{et al.} furthermore investigates the changes in smells over time, and discusses their impact~\cite{Olbr2009}.

Within end-user programming, this paper builds upon two lines of related work. Firstly, the work of Stolee and Elbaum that studied smells~\cite{StoleeTSE2013} and refactorings~\cite{Stolee2011}. They designed a number of smells by transforming known OO smells to the domain of Yahoo! Pipes. The second direction is the work by Hermans \emph{et al.} that also took OO smells as an inspiration from a number of smells~\cite{Hermans2012intra, Hermans2012inter}. Subsequently they described corresponding refactorings~\cite{Hermans2012intraExt} and a tool that applies refactorings~\cite{hermans2014bumblebee}. This final work builds upon previous work by Badame and Dig that described the first spreadsheet refactoring tool RefBook~\cite{badame2012refactoring}.

In end-user programming environments, user input and logic are often more closely linked than they are in general purpose languages, and as such analyzing the input data as opposed to the logic can also be used as a means of \emph{smell detection}. This is a direction that has been spplied to spreadsheets. Cunha et. al \cite{cunha2012towards} for example look at anomalies in the data and define these as smells. Examples of this are \textit{Standard Deviation} which occurs if one assumes a normal distribution for a column in numeric values and the column contains values which fall outside two standard deviations. In more recent work, Barowy et. Al \cite{barowy2014checkcell} take a more formalized approach which they label ``Data Debugging''. Their solution uses statistical analysis to find values with an unusually high impact on the calculated results in a spreadsheet, as such values are likely either very important or erroneous.

In addition two above described work on Yahoo! Pipes and spreadsheets, there is previous smells work on other end-user environments too, like performance smells in LabView, a visual language for system-design~\cite{chambers2013smell, chambers2015impact}. 

Finally, there is some, albeit limited, work on detecting code smells in educational languages. \todo{Katie, do you know of more?} Chatley and Timbul describe Kenya, a simple programming language for educational purposes, which they have integrated into the Eclipse environment~\cite{Chatley2005}. They built features that allow the detection of `bad style' in programs to be detected and reported as code is written, concentrating on encouraging students to program like they were taught in class. This work might indicate that smell detection can be useful for education, but the authors unfortunately did not perform an evaluation of the usefulness of this approach.



\section{Discussion}
\label{sec:discussion}

Based on the research and results for smell detection in end-user programming domains, there are many directions for future work in the domains studied and other end-user domains.





\subsection{Threats to Validity}
The threats to validity of this work inherit the threats to validity of the original studies~\cite{Stolee2015, Stolee2011, StoleeTSE2013, Hermans2011, Hermans2012intra, Hermans2012inter, hermans2014bumblebee, badame2012refactoring} on end-user refactoring in spreadsheets and Yahoo! Pipes.

The three domains studied in this paper all happen to be dataflow languages, and the smells and refactorings may not generalize to other end-user programming domains (e.g., Scratch is OO-based). \todo{katie, would you say Kodu is dataflow based too?}


\todo{In Kodu, smells vs. design decisions}

\section{Concluding Remarks}
\label{sec:conclusions}
This paper presents an overview of the work in smell detection for end-user programming languages. More specifically, it synthesizes work on Yahoo!\ Pipes and Excel into a catalog of generally applicable smells in end-user languages. To demonstrate the applicability of the catalog, we apply it to two new domains: \ms~and Kodu, two visual languages aimed at programming education. The results show that indeed many of the catalog's smells apply in the new domains, and small abstractions, duplicate code and dead code occur in these educational languages too, while being of a quite different character than the textual languages aimed at professional developers that the smells were originally defined for. This shows the applicability of these smells, and also warrants further research into issues end-users encounter while programming. The contributions of this paper are:

\begin{itemize}
	\item A catalog of object-oriented-inspired code smells in end-user programs (Section \ref{sec:smells})
	\item Application of the catalog to two new end-user domains focused on education (Section \ref{sec:application})
	\item Identification of future opportunities for smell detection in end-user programming domains, both within and beyond the OO paradigm (Section \ref{sec:beyond})
\end{itemize}

The current work gives rise to more research, for example \todo{future work}

%sentence from the original intro, I think I like it better here, it feels reflecting
The applicability of smells, originally created to detect weaknesses in source code, to other domains shows how powerful the concept is. Furthermore, studying the smells in a fresh context provides new insight on how to use smells in software engineering and even suggests new types of smells. 

\balance

\section*{Acknowledgements}
Special thanks to Stephen Coy for his help with Kodu. This work is supported in part by  NSF SHF-EAGER-1446932 and the Harpole-Pentair endowment at Iowa State University.


\bibliographystyle{IEEEtran}
\bibliography{literaturelist}

\end{document}


=======
\documentclass{sig-alternate}

%Deadline: April 8, 2015
%Call for papers: http://www.computer.org/web/computingnow/swcfp6

\usepackage{url}
\usepackage[table,xcdraw]{xcolor}
\usepackage{eurosym}
\usepackage{amsfonts}
\usepackage{balance}
\usepackage{cite} %this package is awesome - it reorders lists of citations to be in numeric order
\usepackage{pifont}
\usepackage{eqparbox}

% Tables
\usepackage{booktabs}
\usepackage{pbox}
\renewcommand{\arraystretch}{1.2} 
\usepackage{arydshln}
%\renewcommand*\cmidrule{} % No middle lines
%\renewcommand{\arraystretch}{1.5} % Additional spacing with no middle lines
%\renewcommand*\cmidrule{\hdashline[1pt/2pt]}% Dashed middle lines
\renewcommand*\cmidrule{\midrule[0.001em]} % Thin middle lines
%\renewcommand*\cmidrule{\midrule} % Thick middle lines

%Images
%\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

\hyphenation{second-ly ap-pen-dix}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ms}{LEGO MINDSTORMS EV3}
\newcommand{\mbs}{\textsc{my blocks}}
\newcommand{\mb}{\textsc{my block}}
\newcommand{\horiz}{\hspace{2.1pt}}

\newcommand{\ignore}[1]{}

\begin{document}
%\bstctlcite{IEEEexample:BSTcontrol}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{A Catalog of OO-inspired End-User Smells, \\and Application to \ms~and Kodu}
%\title{Perspectives on End-User Refactoring: Past, Present, and Future}

\numberofauthors{3}
\author{
% 1st. author
\alignauthor
David Hoepelman\\
       \affaddr{Delft University of Technology}\\
       \affaddr{Mekelweg 4}\\
       \affaddr{Delft, the Netherlands}\\
       \email{D.J.Hoepelman@tudelft.nl}
\alignauthor
Kathryn T. Stolee\\
       \affaddr{Department of Computer Science}\\
       \affaddr{Iowa State University}\\
       \affaddr{Ames, IA, U.S.A.}\\
       \email{kstolee@iastate.edu}
\alignauthor
Felienne Hermans\\
       \affaddr{Delft University of Technology}\\
       \affaddr{Mekelweg 4}\\
       \affaddr{Delft, the Netherlands}\\
       \email{f.f.j.hermans@tudelft.nl}
}
%\author{David Hoepelman, Katryn Stolee, Felienne Hermans}

\maketitle


\begin{abstract}
In the workforce today, millions of people program without degrees or professional training in software development. 
These end-user programmers perform a variety of tasks, from combining web information to building models to support business decisions. Software engineering research into code smells has traditionally focused on professionally used object-oriented programming languages, yet these end-user domains and languages also suffer from code smells. 

In this work, we explore recent research in two distinct end-user domains and languages: spreadsheets in Microsoft Excel and web mashups in Yahoo!\ Pipes. Based on existing OO-smells and their applications to these two end-user domains, we distill a catalog of generic end-user smells. 

We demonstrate the broad applicability of the catalog by applying it to two end-user languages not previously targeted by smell detection and refactoring research, both aimed at education: \ms~and Microsoft's Kodu. The results of this application show that indeed OO inspired smells occur in both end-user languages, most commonly we find that small abstractions, duplication and dead code are common. We conclude the paper by proposing new end-users smell, moving beyond the OO paradigm. 
\end{abstract}


\section{Introduction}
End-user programmers are said to outnumber  professional programmers three times over \cite{Scaf2005}.
These end-user programmers perform a wide variety of tasks within their organizations, ranging from creating new web streams to building and maintaining applications in a spreadsheet. While performing these tasks, end-user programmers face many of the challenges of professional developers, such as identifying faults, debugging, or understanding code written by someone else~\cite{Ko2011}.

Similar to code written by professional developers, end-user artifacts may have a long life-span, the average lifespan of a corporate spreadsheet being five years~\cite{Hermans2011}. During this long lifespan, end-user artifacts are modified, often by different people.
These properties make them, like source code artifacts, vulnerable to \emph{smells}. 

The taxonomy of smells outlined in Fowler's text pertained to object-oriented (OO) code, and professional programming languages were the focus for at least the first decade of refactoring and code smell research~\cite{Mens:2004:SSR:972215.972286}, but in the past few years, research has also been done into smells in end-user programming. Most notable are structural smells in Yahoo!\ Pipes web mashups~\cite{Stolee2011} and Excel spreadsheets \cite{Hermans2012inter}. Experiments in end-user areas have shown that end-user programmers understand smells, and often prefer versions of their code that are non-smelly \cite{Hermans2012intra, StoleeTSE2013, chambers2013smell}. 

% Related is also the work by Chambers and Scaffidi who study performance smells in LabView programming~\cite{chambers2013smell}.

In this paper we combine the two end-user smell approaches and obverse that many of the OO smells are applicable in both domains, either they have been already studied, or they could be. This led us to the introduction of a generically applicable, OO-inspired end-user smells. To demonstrate the broad applicability of the catalog, we applied it to two new end-user domains aimed at education: \ms~and Kodu. The results of the application show that OO inspired smells from our catalog in fact occur in both end-user languages, underlining the power of the code smells concept: they also apply on visual languages aimed at education, which are quite different from the textual languages aimed at professional developers that the concept was initially designed for. 

In EV3 and Kodu, the smells that we most commonly find are small abstractions (lazy class), duplication and dead code. In addition to the application of OO smells to the two new domains, we also move beyond the OO paradigm and hypothesize on domain specific smells for our four studied end-user languages: Excel, Yahoo! Pipes, EV3 and Kodu. The contributions of this work are as follows:

\begin{itemize}
	\item Synthesis and catalog of object-oriented-inspired code smells in end-user programs
	\item Application of the catalog to two new end-user domains focused on education: \ms~and Kodu
	\item Identification of future opportunities for domain-specific, non OO-inspired smell detection in end-user programming domains
\end{itemize}


\section{Background}
\label{sec:background}
In this section we briefly explore the two end-user languages targeted by prior smell research, before presenting the relevant end-user code smells in Section~\ref{sec:smells}.



\begin{figure}
\caption{Microsoft Excel 2013 showing a spreadsheet. Column B and C shows the typical mix of data and calculation. The formula of the selected cell B17 is visible right above the spreadsheet.}
\centering
\includegraphics[width=\columnwidth]{img/excel-2}
\label{fig:spreadsheetexample}
%file: fin_accounts from Euses / financial
\end{figure}

\noindent \textbf{Excel:} Spreadsheets are very commonly used in businesses, from inventory administration to educational applications and from scientific modeling to financial systems.
Winston ~\cite{Wins2001} estimates that 90\% of all analysts in industry perform calculations in spreadsheets. 
Microsoft Excel is by far the most used, and therefore most studied, spreadsheet program, but other implementations exists and are similar.

In modern spreadsheet programs, a \textit{cell} can contain a single \textit{formula} which performs a calculation, and a table of cells is bundled in a \textit{worksheet}; an example is shown in Figure~\ref{fig:spreadsheetexample}. 
A \textit{workbook} consist of a collection of worksheets.
Formulas can reference other cells in the same or in different workbooks and worksheets.


\noindent \textbf{Yahoo!\ Pipes:}
Yahoo!\ Pipes is a popular web mashup language and environment with which RSS feed information can be collected and combined from various sources.  Figure~\ref{fig:ypexample} shows an example program. The boxes represent modules connected by wires. 
Abstraction is possible with \emph{subpipe} modules, which allow a programmer to insert a different pipe as a subroutine, appearing like a standard module. 

\begin{figure}
\caption{Example of a program in Yahoo!\ Pipes. It has five RSS feed data sources, each in a \emph{Fetch Feed} module, feeding to a \emph{Union} module that concatenates the feeds, a \emph{Truncate} module that limits the number of items to 15 prior to the final \emph{Pipe Output}. }
\centering
\includegraphics[width=\columnwidth]{img/yp-1}
\label{fig:ypexample}
\end{figure}


\section{Smells in end-user programs}
\label{sec:smells}
Research into end-user language smells has had two approaches, which are not mutually exclusive.
The first approach is to take existing smells for OO programming languages, usually those defined by Fowler~\cite{Fowl1999}, and transform them to be applicable to the end-user environment \cite{Hermans2012inter,Hermans2012intra,Stolee2011,StoleeTSE2013, chambers2013smell}.
The second approach is to define smells tailored to the end-user environment.
This can be done by interviewing experienced end-users to see which smells they perceive \cite{chambers2013smell}, by looking at user reports like forum or newsgroup posts~\cite{badame2012refactoring,chambers2013smell}, or by analyzing publicly available repositories \cite{Stolee2011,StoleeTSE2013,Hermans2012intra}.

This section provides an overview of different smells that researchers have found to be applicable to end-user artifacts using both the above described approaches and proposes future directions for smell detection in these domains. 

\begin{table*}
\caption{Catalog of Code Smells in End-User Programs
\label{table:oosmellslarge}}
\centering
\sffamily
\begin{tabular} {@{}llll@{}}
\toprule
\textbf{OO Smell}
	& \textbf{Excel}
	& \textbf{Yahoo!\ Pipes}
\\ \midrule
Dead Code
	& %~\ding{55}
	& Unnecessary Module \cite{StoleeTSE2013}
\\ \cmidrule
Duplicate Code
	& Duplicated Formulas \cite{Hermans2012intra}
	& Duplicate Modules, Duplicate String or
\\ % Continuation
& 
& Isomorphic Paths \cite{StoleeTSE2013}
\\ \cmidrule
Feature Envy
	& Feature Envy \cite{Hermans2012inter}
	& %Feature Envy *
\\ \cmidrule
Inappropriate Intimacy
	& Inappropriate Intimacy \cite{Hermans2012inter}
	& %Inappropriate Intimacy *
\\ \cmidrule
Lazy class or Middle Man
	& Middle Man \cite{Hermans2012inter}
	& Unnecessary Abstraction \cite{StoleeTSE2013}
\\ \cmidrule
Long Method
	& Multiple Operations \cite{Hermans2012intra}
	& Noisy Module : Duplicate Field \cite{StoleeTSE2013}
\\ \cmidrule
Many Parameters
	& Multiple References \cite{Hermans2012intra}
	& 
\\ \cmidrule
Message Chain
	& Long Calculation Chain \cite{Hermans2012intra}
	& 
\\ \cmidrule
No-op
	& %Redundant Operations *
	& Unnecessary Module \cite{StoleeTSE2013}
\\ \cmidrule
Unused Field
	& %~\ding{55}
	& Noisy Module : Empty Field \cite{StoleeTSE2013}
\\ \cmidrule
Use of Deprecated Interfaces
	& %Deprecated Functions *
	& Deprecated Module or Invalid Source \cite{StoleeTSE2013}
\\ \bottomrule
%\multicolumn{4}{c}{} \\
%\multicolumn{4}{l}{\ding{55} : Not applicable due to the nature of the paradigm} \\
%\multicolumn{4}{l}{* : Proposed smell, likely future opportunity not supported by prior work}\\
%\multicolumn{4}{l}{$\langle$blank$\rangle$ : Not discussed in this work, possible future opportunity} \\
%\multicolumn{4}{l}{\todo{fill all empty spots, they should either be explicitly NA or possible}} \\
\end{tabular}
\end{table*}



%\subsection{OO Smells in End-User Programs}
%\label{sec:smells:oo}
 We summarize the OO smells present in two end-user languages, Excel spreadsheets and Yahoo!\ Pipes mashups, in Table~\ref{table:oosmellslarge}.
 Overall, we often observe similarities in the code smells studied. For example, the \emph{Duplicate Code}, \emph{Lazy Class}, and \emph{Long Method} smells  have been studied in both languages. 
% \todo{is this a fair assesment?}
We note that the absence of an entry in Table~\ref{table:oosmellslarge} does not mean the absence of the smell in that language, it simply means such smells have not been studied. We speculate on a few of these opportunities in Section~\ref{subsec:futuresmells}. 

% Some smells, like the \emph{Long Method} smell, have been studied in only one domain but are likely applicable in the other domain, these are marked with *.  These smells present opportunities for future research, detailed in Section~\ref{subsec:futuresmells}.
 
% In this section we will detail the application of OO smells on specific end-user languages.
 
% A small number of smells are definitely not applicable (\ding{55}) because of differences in the domains. Spreadsheets, for example, cannot contain dead code because the user might still be interested in a piece of data even if it is not used anywhere else in the spreadsheet.

 \subsection{Excel}
Hermans et al. \cite{Hermans2012inter,Hermans2012intra} analogize a workbook to a program, a worksheet to a class inside that program and a cell to a method and use this to transform nine of Fowlers smells.
An example of this is the \emph{Long Method} smell, which translates to the \emph{Multiple Operations} smell because formulas with a large number of operations suffer from similar problems as long methods. In an industrial case study with 10 spreadsheet users, the smells were found understandable by users, and with the smells errors in real-life spreadsheets were found.

\subsection{Yahoo!\ Pipes}
Stolee and Elbaum~\cite{Stolee2011, StoleeTSE2013} treat a Yahoo!\ Pipes mashup as a class and each module as a method.  Fields in a module are treated as parameters. Using this analogy,  several OO smells were mapped to this language. The most common smell, appearing in nearly one-third of the 8,000 pipes studied, was \emph{Duplicate Strings}, an instance of Fowler's \emph{Duplicate Code} smell. 
\emph{Duplicate Modules}, impacted nearly one-quarter of the pipes studied. 
 Overall, 81\% of the programs studied from the Yahoo!\ Pipes community had at least one smell. 
 
Yahoo!\ can also \emph{deprecate modules}, which can create similar problems to using deprecated or old versions of interfaces.


\begin{figure} [ht]
\caption{The interface of \ms~showing a simple line following program.}
\centering
\includegraphics[width=\columnwidth]{img/ms}
\label{fig:ms}
\end{figure}

\subsection{Further Applications of OO smells}
\label{subsec:futuresmells}
Although not all OO smells have been studied in both domains, indicated by empty places in Table \ref{table:oosmellslarge}, this does not mean they do not apply. For example, Feature Envy is not discussed in previous work on Yahoo! Pipes, but could apply when \todo{Katie, how exactly?}. Similarly, redundant operations could occur in Excel, in fact, they do. A formula like SUM(A1+A2+A3), which we have seen in practice, exhibits the No-Op smell, as the SUM function does not add anything. While the occurrence of these smells falls outside of the scope of the current work, in this section we discuss the potential of generalizing some of the OO and domain-specific smell definitions to additional domains, thus addressing the empty places in Table \ref{table:oosmellslarge}.

\subsubsection{Excel}
Most of the smells studied in other end-user domains have been studied in Excel spreadsheets, but there is future potential in the areas of redundancy and deprecation. The \emph{Dead code} smell

Furthermore, research in smells and spreadsheets has focused on Microsoft Excel. However, other spreadsheet software exists and operates on the same principles. Thus there is also an opportunity to confirm that the identified smells apply in other spreadsheet software.

\subsubsection{Yahoo!\ Pipes}
\label{sec:smells:future:yp}
%Many of the smells studied in Excel and LabVIEW could apply to Yahoo!\ Pipes, and in particular, \emph{Feature Envy} and \emph{Inappropriate Intimacy}. 
%uses methods of another class excessively - envy
The \emph{Feature Envy} smell could  apply when introducing abstraction. For example, if a pipe has several instances of the same subpipe module, this could be excessive use of another class. 

%depends on implementation of another class too much - intimacy
When a program uses too much abstraction relative to the size of the pipe, it could suffer from \emph{Inappropriate Intimacy} by depending too much on the implementation of the other class. In fact, in an empirical evaluation, programmers often preferred pipes without subpipe modules because they were easier to understand~\cite{StoleeTSE2013}. 

%long method
A \emph{Long Module} smell could apply when a module has a large number of fields. For example, the \emph{Fetch Feed} module, as in Figure~\ref{fig:ypexample}, can hold one or more URLs. When the number of URLs makes the method so big it does not fit on the screen, this would likely impact the understandability of the pipe. 

Drawing inspiration from the domain-specific \emph{Inconsistent Formula} smell in Excel, identifying program patterns that are close, but not exactly the same, could identify missed opportunities for abstraction or errors in the mashup structure. 


%\subsubsection{Other Domains}
%End-user programming domains extend beyond spreadsheets and web mashupss. Stolee and Elbaum explore future opportunities for refactoring in educational programming languages~\cite{StoleeTSE2013}. \todo{revisit, this is a bit strange now this paper talks about education too}

%Other end-user programming domains that could benefit from smell analysis and refactoring are mathematical environments like MATLAB, Sage, and Mathematica.

%In particular, the smells related to duplication and poor construction like \emph{Long Method}, \emph{Many Parameters} and \emph{Dead Code} are prevalent in the four domains studied.
%These smells -- and their respective refactorings -- likely exist in other end-user programming domains, and likely hinder the understandability and maintainability of those programs. Worse even, these smells could lead to errors, and thus these smells are worthy of our attention. 

%\subsection{Future Opportunities in Professional Languages}
%In end-user programming languages, it has been shown that code smells impact the understandability of
%source code~\cite{StoleeTSE2013}. Additionally, being presented with code smells can motivate end-user programmers to improve their code~\cite{chambers2013smell}, and smells in spreadsheets have even been known to reveal actual errors~\cite{Hermans2012intra}. These lessons could extend to professional programming languages. but further study is needed. 
% outside of the end-user programming domains. 
%There has been successful in using automating smell detection, for example, during agile development (e.g.,~\cite{Schumacher:2010:BES:1852786.1852797}). Paired with the end-user evidence, a stronger case can be made to integrate automated smell detection in many domains. 

%\todo{Other data flow languages could benefit from \emph{normalize order of operations} to improve understandability (as it does with YP). }


\section{Application}
\label{sec:application}
In Section~\ref{sec:smells}, we distill a catalog of end-user smells from previous work. In order to demonstrate the applicability of our catalog, we apply it to two new domains: \ms~software (EV3 for short) and  Kodu. 

\subsection{\ms}
\ms~is the third iteration of the LEGO MINDSTORMS robotics line. It consists of a number of sensors, four motors and an ARM 9 ``intelligent brick''. The robotics kit comes with a control software package, which allows for visual programming of the brick. The software supports several basic constructs common to programming, including loops and conditionals, but also more advanced features like parallel execution. Figure \ref{fig:ms} shows the user interface of the EV3 software with a program that makes a robot follow a black line by steering left if the sensor value is below the threshold of 7 and right if the value is above, and in parallel writes the sensor value to the screen. Blocks have to be connected by wires, like the two coming from the `Play button' that acts as the starting point, to be executed. The program in Figure \ref{fig:ms} demonstrates some of the basic EV3 programming concepts including parallel execution, loops and switches.

In addition to the programming concepts described above, users have the possibility to define `\mbs' which basically are subroutines. \mbs~may have up to 9 different input and one output parameter. \mbs~cannot be programmed from scratch; they can only be created by selecting blocks in an existing program and creating a new block for them, together with a call to the newly created block, an action extremely similar to `extract method' present in most modern IDEs. 

\subsubsection{Smells  in \ms}
In this subsection we describe how the smells in our OO-inspired catalog apply to EV3 programs. As common in the other approaches, we define a loose mapping of OO concepts to the end-user language in question to be able to translate the smells. In EV3 programming, there are  \emph{\mbs~} that contain a number of blocks, can be used multiple times and can use input and output. As such they resemble methods in source code, modules in Yahoo! Pipes and worksheets in spreadsheets. Based on this translation, we investigate which of the smells in our catalog could apply to EV3 programs too. \todo{in what order should we present the smells? I think alphabetical makes more sense than no ordering?}

\begin{description}
\item[Dead Code] It is possible for programming blocks to be disconnected, but the interface clearly indicates this by making them gray \todo{added picture here?}. However, unused \mbs~can be present in the project without a warning being issued. This is smelly as it makes the program unnecessarily large.
\item[Deprecated Interfaces] This is a smell that does not apply, as, to date, there is only one version of the EV3 software and no blocks have been depreciated.
\item[Duplicate Code] When the same, or very similar combinations of blocks occur, this would be the duplicate code smell.
\item[Feature envy] While all defined variables within EV3 programs are global, they can be written in a certain \mb~but read in a different one. If, in a given \mb~many variables are read that have been written somewhere else, this might be an occurrence of the feature envy smell. 
\item[Inappropriate Intimacy] Variables might be read in one \mb~but written somewhere else. If there are two \mbs~sharing multiple variables this way, it might be better to combine them.
\item[Lazy Class] If a \mb~is very small, for example, consisting of just one block, they do not add a lot of value, while making the program harder to understand, as a user has to navigate to the \mb~to see what its function is.
\item[Long method] If a \mb~grows very large, it will no longer be easy to understand, counteracting the added value of the abstraction.
\item[Many Parameters] \mbs~can have 9 different parameters, which could be considered too much for easy understandability, especially since parameters need to be connected with wires, potentially leading to visual clutter in the case of many parameters.
\item[Message Chain] Because \mbs~can have both input and output parameters, it is possible that they created a message chain in which values are continuously passed until they are used, while they could have been passed outside of the \mbs~.
\item[No-op] It is possible to combine blocks in such a fashion that they do not actually contribute to the functionality of the program. For example, it a user stops the same motor twice, the second stop will be a no-op.
\item[Unused Field] As explained above, \mbs~can define parameters. However, the user is not forced to use them, hence it is possible to define more parameters than used.

\end{description}


\begin{figure} [ht]
\caption{Two blocks representing the same functionality, one in a regular block and one using a \mb.}
\centering
\includegraphics[width=3cm]{img/weg}
\label{fig:weg}
\end{figure}

\subsubsection{Study context}
To determine if EV3 programs indeed suffer form the above defined smells, we have gathered 17 programs from two data sources. The first source is robotics club ran by one of the authors of this paper. It is a club where kids aged 8 to 13 program robots every week. Their programs have been collected as dataset for this paper. More specifically, we focus on two different projects within this set, RoboCup and Sumo. These two types of programs related to two different LEGO MINDSTORMS competitions: Sumo is a simple robot game in which robots have to `sumo wrestle' each other: the robot that gets pushed out of the circular competition area first loses\footnote{\url{http://www.sugobot.com/}}. The Robocup programs were made to participate in the RoboCup Junior Rescue challenge\footnote{\url{http://rcj.robocup.org/rescue.html}}, where robots have to first navigate part of the field by following a line and subsequently look for a soda can and push it out of the field.

To obtain a more diverse set of EV3 programs, we have solicited members of the EV3 programming group on Facebook to share their programs with us\footnote{\url{https://www.facebook.com/groups/legomindstorms/permalink/527560164058881/}}.

\subsubsection{Findings}
When investigating the programs, we found that they indeed can suffer from OO-inspired smells. There are only two smells that do not occur in any of the programs: Inappropriate Intimacy and Message Chain. Duplicate Code occurs most, in over half of the programs. 

Table \ref{tab:robotica} presents an overview of the smells found in the EV3 programs.


\begin{figure} [ht]
\caption{The project properties screen for the Sumo program 1, showing the three \mbs~, but not indicating the \mb~`draaien' is currently not called from the main program.}
\centering
\includegraphics[width=\columnwidth]{img/overview}
\label{fig:overview}
\end{figure}

\paragraph{Duplicate Code}
The most common smell we found in the nine programs is the Duplicate Code smell, which 11 out of 17 programs suffer from. Duplication comes in various forms, some of the programs use two motor blocks in a row, that could have been merged, like the two blocks from program L17, shown in Figure \ref{fig:dup_ev3}. This might have been challenging for the users to detect, as they use two slight variations of the motor block, but the two behave exactly the same in this special case, where the direction is straight forward. Other programs exhibit duplication at a high level, like two \mbs~in program L16, depicted in Figure \ref{fig:dup_ev3_myblocks}. Here, the two \mbs~perform the exact same operation, but on a different motor. By connecting the name of the motor to a parameter two, this functionality could have been implemented with one \mb.

\begin{figure} [ht]
\caption{The duplication smell in two subsequent motor blocks. Since both have the same power and direction, they could have been merged. }
\centering
\includegraphics[width=\columnwidth]{img/dup_ev3}
\label{fig:dup_ev3}
\end{figure}

\begin{figure} [ht]
\caption{The duplication smell in two different \mbs. Both \mbs~turn a motor, and which motor could have been put in a parameter, like angle and speed already are. }
\centering
\includegraphics[width=\columnwidth]{img/dup_ev3_myblocks}
\label{fig:dup_ev3_myblocks}
\end{figure}

\paragraph{Dead Code}
The second most common smell is Dead Code. In seven out of 17 programs we found \mbs~that no longer connected to one of programs. This can pose a problem, as the EV3 environment compiles and transfers all programs and \mbs~to the brick, causing the memory to be full quite quickly. We see that Dead Code is more common in the robotics class programs than in the programs we received via Facebook. This is probably due to the fact that these users felt confident enough to share their programs, because either the programs were reviewed before sharing them, or the experience users selected `nice' programs to share.

Looking at the EV3 programming interface, it is not that surprising that users forget about disconnected \mbs. The interface does not help users in understanding what \mbs~are used. If we look at the project properties screen, shown in Figure \ref{fig:overview}, one can see that there is no information about which \mb~is used where. Even worse, user can delete \mbs~that are still being called, without a warning being issued about this. After removal of a \mb~ in use, the program no longer compiles.

\begin{table*}[]
\centering

\caption{Size in terms of the different number of blocks used in the seventeen \ms~programs, and the smells they exhibit \todo{deprecated interfaces?}}
\label{tab:robotica}
\sffamily
\begin{small}
\begin{tabular}{l|lllll|lll|lllllllll}
Name & L1  & L2 & L3  & L4  & L5  & L6  & L7  & L8  & L9  & L10 & L11 & L12 & L13 & L14 & L15 & L16 & L17 \\
\hline
Data         & 1  & 0  & 2  & 5  & 0  & 0  & 4  & 4  & 1  & 0  & 0 & 2  & 0  & 7  & 1 & 1  & 0   \\
Actor        & 8  & 6  & 5  & 7  & 16 & 8  & 10 & 16 & 10 & 1  & 2 & 1  & 7  & 15 & 2 & 2  & 78  \\
Sensor       & 1  & 0  & 0  & 2  & 1  & 0  & 8  & 10 & 4  & 1  & 0 & 1  & 0  & 4  & 2 & 0  & 0   \\
Logic        & 3  & 5  & 4  & 4  & 4  & 3  & 7  & 11 & 2  & 2  & 1 & 4  & 11 & 2  & 0 & 0  & 25  \\
MyBlock Call & 2  & 0  & 2  & 2  & 3  & 4  & 3  & 5  & 0  & 1  & 0 & 1  & 0  & 3  & 1 & 4  & 27  \\
Comment      & 2  & 0  & 0  & 1  & 0  & 0  & 1  & 0  & 0  & 6  & 6 & 0  & 15 & 0  & 0 & 7  & 13  \\
Variables    & 0  & 0  & 1  & 3  & 1  & 1  & 0  & 0  & 0  & 0  & 0 & 0  & 0  & 19 & 0 & 0  & 0   \\
MyBlocks     & 3  & 0  & 3  & 2  & 3  & 2  & 2  & 4  & 0  & 1  & 0 & 1  & 0  & 4  & 1 & 3  & 6   \\
\hline
Total        & 20 & 11 & 17 & 26 & 28 & 18 & 35 & 50 & 17 & 12 & 9 & 10 & 33 & 54 & 7 & 17 & 149\\
\hline
\hline
Dead Code                                              & \ding{51} &  & \ding{51} & \ding{51} &   &   & \ding{51} & \ding{51} &   &   &   &   &   & \ding{51} &   &   & \ding{51} \\
Deprecated                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Duplicate Code                                         &   &  &   & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} &   & \ding{51} &   &   & \ding{51} & \ding{51} \\
Feature Envy                                           & \ding{51} &  & \ding{51} & \ding{51} &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Inappropriate Intimacy                                 &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Lazy Class                                             & \ding{51} &  & \ding{51} & \ding{51} &   & \ding{51} &   &   &   &   &   &   &   &   &   &   &   \\
Long method                                            &   &  &   &   & \ding{51} &   &   &   &   & \ding{51} &   &   &   & \ding{51} &   &   & \ding{51}   \\
Many Parameters                                        &   &  &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &   &   &   \\
Message Chain                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
No-op                                                  &   &  & \ding{51} &   &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &  \\
Unused Field                                           &   &  &   & \ding{51} &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &   \\
\hline
Total Smells & 3 & 0 & 4 & 5 & 2 & 2 & 2 & 2 & 1 & 2 & 1 & 1 & 1 & 4 & 0 & 1 & 3
\\
\end{tabular}
\end{small}
\end{table*}


\paragraph{Lazy Class}
Lazy classes, which we counted as \mbs~containing three or fewer blocks, are also relatively common, occurring in four of the programs. However, we only find this smell in the programs from the robotics club and not in the programs received via Facebook. Many of `lazy \mbs'~were relatively small, consisting of two or three blocks, or even one in some cases. You could say this is smelly, as understanding the \mb~requires clicking it and that might not be worth it for small \mbs. However, the EV3 programming interface does not allow regular blocks to be named, but it does allow this for \mbs. So by making a \mb, users can express the intent of a coherent set of blocks, even if this set consist of just one block. 

As an example, consider the two blocks shown in Figure 5, where the upper one is regular block controlling a motor, while the lower one is a call to a \mb~with the same functionality. The first one just expresses what the robot must do, but the second one expresses the intent (`weg' meaning flee). By using the \mb, even with one block, the program gets easier to read.

\paragraph{Long method}
Long Method \todo{add threshold here} too occurs in four programs, but, contrary to Lazy Class, is found mostly in the Facebook programs. This is to be expected, more experienced users can handle bigger \mbs, while the kids from the robotics club stick with making small blocks.

\subsubsection{Summary}
To summarize, we again observe that smells stemming from OO are applicable to end-user domain: duplicate code, dead code and small abstractions seem to be anti-patterns that occur in programming in general, independent of the programming language. It is remarkable to see that even in a visual language, quite different from the textual, high-level languages for which the smells were originally designed, the same smells occur.


\subsection{Kodu}
Microsoft Research's Kodu is a visual programming language~\cite{kodugrammar} and environment that allows users to create, play, and share their own video games. 
It is available for download on the Xbox and PC and is heavily inspired by robotics, and the context of programming in it and its language both show this. 
Users can program each character or object (e.g., a kodu, cycle, apple, tree; we use character and object interchangeably) individually, and the programming defines how to interact with the world. Each object has 12 pages that can be programmed, analogous to methods in an OO language, where the current page defines the current behavior of the object. 
The object's behavior can change by switching between pages to modify state and control flow. 
Each page contains a set of rules, and each rule is in the form of a condition and an action, which form a when~--~do clause. The \emph{when} is defined by a sensor (e.g., see, hear, gamepad input) and filters (e.g., apple, gamepad A button). The \emph{do} is defined by an actuator (e.g., movement, shoot) and modifiers (e.g., missile, toward). All the rules on a page are evaluated in a single frame, from top to bottom. 
Despite its unique language, Kodu  can be used to express many basic concepts in computer science, such as variables, boolean logic and conditional control flow~\cite{Stolee:2011:ECS:1953163.1953197}. 

Figure~\ref{fig:Kodu} shows a page and two rules  in Kodu. For the first rule, the condition is, when see red apple, and the action is, move toward it. The action defines the behavior of this particular character when it sees a red apple, that is, it moves toward it. Since the condition identifies an object (i.e., apple), it becomes the default selector, even though it is not explicitly specified. The second rule has a similar condition with a different sensor, bump. The action of the second rule, eat, indicates that the character should eat any red apple it bumps. 
Rules can also be indented to create complex \emph{when} clauses, where both conditions need to be true for the action to occur. Alternatively, indenting a rule and removing the \emph{when} means that multiple \emph{do} clauses occur for the same trigger condition. 
The programming in Figure~\ref{fig:Kodu} applies to the first page in this character's programming, as indicated by the number one at the top of the screen. The first page is the default start page.


\begin{figure}[ht]
\caption{The interface of Kodu~showing programming behavior for a bot.}
\centering
\includegraphics[width=\columnwidth]{programmingui.png}
\label{fig:Kodu}
\end{figure}



\subsubsection{Smells in Kodu}
We describe how the smells in our OO-inspired catalog apply to Kodu programs. We define a loose mapping of the OO concepts to the end-user language. We consider pages of programming as analogous to methods or classes, similar to how modules are treated in Yahoo!\ Pipes, worksheets in spreadsheets and \mbs~in \ms. 

\begin{description}
\item[Dead Code] If there exists a page with programming such that there is no explicit path of control flow from Page~1 to it, it is unreachable and therefore dead. 
\item[Deprecated Interfaces] Some language features and bots may exist in early versions of Kodu but not be available in future versions. use of these deprecated entities may cause unexpected behavior when running an old program in a new environment and be smelly. 
\item[Duplicate Code] Two pages for the same character with exactly the same set of rules, or two identical rules on a page constitute duplicate code. Alternatively, two rules on the same page with the same \emph{when} clauses (i.e., sensor and filter) but different actions could be consolidated using the indent feature and thus are smelly. 
\item[Feature envy] All global variables, such as game scores, can be read and written by any character. If a certain character reads variables that have been written by another character, this could be an instance of the feature envy smell. 
\item[Inappropriate Intimacy] A character has four local properties that describe its state: color, glow color, expressions (angry, crazy, happy). If one character frequently checks the properties of another character, this could constitute inappropriate intimacy. 
\item[Lazy Class] If a character has no programming, it could be an instance of the lazy smell. 
%Characters with no programming are different than objects. Characters can have movement whereas objects cannot. 
\item[Long method] A page with many, many rules may be difficult to understand. Some programming could potentially move to other pages or other characters. We counted long methods as those with more than five rules. 
\item[Many Parameters] A game can have 37 different global scores. Games that use many of these could be unnecessarily smelly. 
\item[Message Chain] It is possible for a character to create a chain of switches between pages without any logic on the page other than the jump. This would create a long and unnecessary message chain. 
\item[No-op] Jumping to a page with no logic is the logical equivalent of a null pointer. While no error would be raised, the character would no longer have any behavior and would be stuck in that state. Alternatively, rules with \emph{when} clauses but no \emph{do} clauses do not perform any actions. 
\item[Unused Field] A global variable that is written to but not read is an instance of the the unused field smell. 

%\todo{emailed scoy at Microsoft about this}
\end{description}



\begin{table*}[]
\centering

\caption{Size in terms of the different number of characters and rules used in the 17 Kodu programs, and the smells they exhibit}
\label{tab:koduanalysis}
\sffamily
\begin{small}
\begin{tabular}{l | r@{\horiz }r@{\horiz }r@{ \horiz}r@{ \horiz}r@{\horiz }r@{ \horiz}r@{\horiz }r@{\horiz }r@{ \horiz}r@{ \horiz}r@{ \horiz}r@{\horiz }r@{\horiz }r@{ \horiz}r@{\horiz }r@{ \horiz}r@{\horiz } | r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r@{\horiz }r}
Name & K1  & K2 & K3  & K4  & K5  & K6  & K7  & K8  & K9  & K10 & K11 & K12 & K13 & K14 & K15 & K16 & K17 & K18 & K19 & K20 & K21 & K22 & K23 & K24 & K25 & K26 & K27\\
\hline
Characters        & 6&17&39&21&62&60&85&26&26&60&42&45&57&36&5&15&28
&28&10&2&16&18&76&75&63&4&76
\\
Pages 		&11&7&26&19&18&47&82&19&10&60&41&31&10&9&6&7&7
&34&16&2&39&18&9&50&90&8&78
\\
Rules 		&21&17&60&28&31&96&93&29&20&120&58&63&22&35&14&18&23
&114&54&3&113&27&30&122&144&32&372
\\
%Tiles        	& 90&64&252&150&121&418&535&141&66&227&230&244&81&159&54&90&103\\
HCI Actors & 1&2&1&1&2&1&1&1&1&1&1&1&1&0&2&1&1
& 5 & 1 & 0 & 0 & 1 & 1 & 1 & 37 & 0 & 2
\\
%\hline
%Total        & 20 & 11 & 17 & 26 & 28 & 18 & 35 & 50 & 17 & 12 & 9 & 10 & 33 & 54 & 7 & 17 & 149\\
\hline
\hline
Dead Code                                              &   &  &   &   &   &   &   &   &   &   &   &   &  \ding{51} &   &   &   &   
& & & & & & & \ding{51} & \ding{51} & &
\\
Deprecated                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   
& & & & & & &  & & & 
\\
Duplicate Code                                        &   &  & \ding{51}  &   &   & \ding{51}  & \ding{51}  & \ding{51}  & \ding{51}  &   &   & \ding{51}  &\ding{51}   & \ding{51}  &   & \ding{51}  &   
& \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & & \ding{51} & \ding{51} & & \ding{51}
\\
Feature Envy                                         &   &  & \ding{51}  &   &   &   &   &   &   & \ding{51}  &   &   &   &   &   &   &   
&  &  \ding{51}& & & & & \ding{51} & \ding{51} & & \ding{51}
\\
Inapprop. Int.                            &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &  \ding{51} &   
& & & & & & & & & &
\\
Lazy Class                                             &   & \ding{51} & \ding{51}  & \ding{51}  & \ding{51}  &\ding{51}   &\ding{51}   &\ding{51}   &\ding{51}   &   & \ding{51}  & \ding{51}  & \ding{51}  & \ding{51}  & \ding{51}  &  \ding{51} &\ding{51}   
& \ding{51} & & \ding{51} & \ding{51} & &  \ding{51}&  \ding{51}&  \ding{51}& & \ding{51}
\\
Long method                                        &  &  &  &   &   &\ding{51}   & &   & &   &   & \ding{51}  & \ding{51}  &   &   &   &    
&  \ding{51}& \ding{51} & & & & & \ding{51} & & & \ding{51}
\\
Many Params                                        &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   
& & & & & & &  &  & & \ding{51}
\\
Message Chain                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   
& & & & & & & \ding{51} & & &
\\
No-op                                                  &   & \ding{51} &   &   &   &   &   &   &   & \ding{51}  &   & \ding{51}  & \ding{51}  & \ding{51}  &   &   &\ding{51}   
& & \ding{51} & \ding{51} & & & &  \ding{51}&  \ding{51}& & \ding{51}
\\
Unused Field                                           &   &  &  \ding{51} &   &   &   &   &   & \ding{51}  &   &   & \ding{51}  &   &   & \ding{51}  &   &   
&  \ding{51}& & & & & & & \ding{51} & & \ding{51}
\\
\hline
Total Smells & 0 & 2 & 4 & 1 & 1 & 3 & 2 & 2 & 3 & 2 & 1 & 5 & 5 & 3 & 2 & 3 & 2 
& 4&4 &3 &2 &1 &1 &7 &6 &0 &7
\\

\end{tabular}
\end{small}
\end{table*}


\subsubsection{Study Context}
To determine if Kodu programs indeed suffer form the above defined smells, we have gathered  programs from two data sources. 
For the first data source, we ran a workshop at the Microsoft FUSE lab that introduced children to Kodu Game Lab in a series of three 3-hour sessions.  To recruit participants, we advertised the Kodu workshop using a mailing list of parents interested in Kodu.  
Children between the ages of 9 and 12 volunteered to participate, with parental consent. We collected 17 programs created during the workshop for analysis. 
For the second data source, we randomly sampled 10 programs from the public Xbox Live community. No demographic information was collected about the users. 

The programs were analyzed by hand by one of the authors. Table~\ref{tab:koduanalysis} presents the 17 programs created by children (K1 \dots K17), 10 programs created by the Xbox Live community (K18 \dots K27), and the smells found in each. The \emph{Characters} row defines how many characters and actors are in the program, \emph{Pages} defines how many pages of programming are used by the characters, \emph{Rules} counts all the rules on all the pages, and \emph{HCI Actors} counts the number of actors in the program that are controllable by the Xbox controller, mouse or keyboard. 
To count the number of instances of the \emph{long method}, a smell was counted when the page had 10 or more rules. For the  \emph{many parameters} smell, the use of four or more game scores. These thresholds were determined by the authors as 10 rules cannot be viewed on a screen screen without scrolling and only a couple games used more than three game scores. 

\subsubsection{Findings}
On average, the programs from children had 2.3 smells each and the programs from the community had 3.5 smells each, though we note that the programs from the community tend to be larger (e.g., an average of 101 rules vs. 42 rules). Next, we discuss the three most common smells found in the Kodu programs, appearing in 40\% or more of the sample. The remaining smells appear in 25\% or fewer programs. 

\subsubsection{Lazy class}
The lazy class smell was the most common, appearing in 79\% of the Kodu programs. This smell is intended to capture when a character is placed in the world but has no programming, and thus no behavior. In some cases, this may not be a smell at all, such as when characters are used as decorations in the world (e.g., trees and rocks). In others, it could be similar to an object that is created but that has no behavior. 

\subsubsection{Duplicate Code}
This smell was present in 61\% of the programs. All instances were that of duplicate \emph{when} clauses within a page, and there were no instances of identical rules on a page or identical pages within the same character. The prevalence of this feature shows a missed opportunity for consolidating the code. 

\subsubsection{No-op}
The next most-common smell is the no-op, present in 41\% of the programs. All instances of this smell were rules without \emph{do} clauses, rather than jumping to pages without logic. This is probably the product of the rapid cycling between testing and developing observed in Kodu development~\cite{Stolee:2011:ECS:1953163.1953197}; since the clauses have no actionable logic, keeping them in the code does not impact the semantics of the program. 

\subsection{Summary}
Table~\ref{tab:smellsummary} summarizes the frequencies of occurrence of the various smells in the  EV3 and Kodu programs. Overall, 88\% of the EV3 and 93\% of the Kodu programs contained at least one smell. Coupled with the 81\% of Yahoo!\ Pipes programs~\cite{StoleeTSE2013} and \todo{X\% of Excel programs} that were previously found to be smelly, this provides further evidence of the prevalence of smells in end-user programs. 

As with code written by other end-user programmers~\cite{StoleeTSE2013}, duplication smells are prevalent in EV3 and Kodu programs, affecting over 60\% of the samples in both languages. Dead code is more frequently found in EV3 and lazy classes are more common in Kodu. Long methods are found in approximately 25\% of the programs in both languages, and \todo{Y\% of the Excel programs}, showing that this smell, too, is common across languages. Feature envy was also prevalent across both languages, appearing in 18\% and 22\% of the EV3 and Kodu programs, respectively. 


\begin{table}
\caption{Summary of Smells Across EV3 and Kodu Programs \label{tab:smellsummary}}
\begin{center}
\begin{tabular}{l | r r}
&EV3&Kodu\\ \hline
Dead Code&41\%&11\%\\
Deprecated Interfaces & & 0\%\\
Duplicate Code&65\%&61\%\\
Feature Envy&18\%&22\%\\
Inappropriate Intimacy&0\%&4\%\\
Lazy Class&24\%&79\%\\
Long method&24\%&25\%\\
Many Parameters&6\%&4\%\\
Message Chain&0\%&4\%\\
No-op&12\%&41\%\\
Unused Field&12\%&25\%\\ \hline
Any smell & 88\% & 93\%
\end{tabular}
\end{center}
\end{table}

\section{Beyond OO}
\label{sec:beyond}

\label{sec:smells:domain}
The end-user programming environments offer many opportunities to define smells based on user behavior or unique elements of the domain. Here, we explore opportunities for new smells in end-user domains that extend beyond the OO-inspired smells in Section~\ref{sec:smells}. 

\subsection{Excel}
In spreadsheets, data is often processed by having each record in a row and having a column with identical formulas to perform some calculation.
This leads to the definition of the \emph{Inconsistent Formula} smell, which occurs if a single, or small number, of cells contain a different formula while its neighbors or other cells in the row or column contain an identical formula.
Interestingly this smell is already detected by Microsoft Excel which warns the user about it.

Another smell specific to spreadsheets is when a formula references an empty cell, which is often in error \cite{cunha2012towards}.
This is comparable to a null pointer in other languages and would be a runtime error, but because a spreadsheet contains both the input data and logic we can directly mark it as a smell.

\subsection{Yahoo!\ Pipes}
%Talk about smells unique to the domain
By exploring a large subset of the Yahoo!\ Pipes repository, Stolee and Elbaum identified a smell based on the presence of broken data sources~\cite{StoleeTSE2013}.
A reference to a broken data sources  is similar to opening a non-existing file, which would be a runtime exception or error in most professional languages.
Such exceptions are not in the Yahoo!\ Pipes language, which is the reason to mark it as a smell. 
%Talk about deriving smells from the community
Similar exploration was used to  identify common programming practices, marking deviations from those practices as smells. 
This is similar to identifying  smells  as anti-patterns  and could be extended to any language. 

\subsection{EV3}
\subsubsection{Wrong motor or sensor mapping}
The \ms~programming language differs significantly from the other end-user domains, as EV3 programmers work with both software and hardware. While programming, users need to configure motor blocks to the right port, for example the blocks in Figure \ref{fig:dup_ev3} are controlling motors A and D. This means that, when a user has the wrong mental model of what motor is connected to what port, the program will not function as wanted. It appears users run into this issue too, as some of the programs we saw comment blocks where the mapping was described \todo{if room add example}.

%Not sure if we should add this, but I have the rule in class that you can only raise your hand to ask a question if you have checked the mapping. And it still goed wrong often. 

Hence a smell unique to the EV3 domain is a wrong mapping between the robot in reality and the motor and sensor blocks. 

\subsubsection{Layout smells}
The EV3 language is a visual language without an auto-layouting function, this means that, when users are making changes to their programs, often the layout can get messy. This also happens when a user creates a \mb, blocks that have been moved to the \mb~ are replaced by a call to the newly created \mb, but other than that the layout remains unchanged. So if a big \mb~is created the program will now have a big gap, making the program harder to read \todo{if room show example}. This, and other layout smells too are unique to visual languages where the layout is not modified by the environment.


\subsection{Kodu}

\section{Related Work}

\label{sec:related_work}
This paper builds upon the extensive body of work related to code smells and refactoring in the end-user programming domain~\cite{Stolee2015, Stolee2011, StoleeTSE2013, Hermans2011, Hermans2012intra, Hermans2012inter, hermans2014bumblebee, chambers2013smell, chambers2015impact}. For an extensive overview in object-oriented research, we refer the reader to the work of Mens and Tourw\'{e} \cite{mens2004survey}.

\subsection{Smells based on user input}
\label{subsec:related_datasmells}
In end-user programming environments user input and logic are often more closely linked than they are in general purpose languages.
As such analyzing the input data as opposed to the logic can also be used to detect problems.

Cunha et. al \cite{cunha2012towards} claim to define code smells for spreadsheet, but for most of their smells they look at  anomalies in the data and define these as smells.
Examples of this are \textit{Standard Deviation} which occurs if one assumes a normal distribution for a column in numeric values and the column contains values which fall outside two standard deviations.
In more recent work, Barowy et. Al \cite{barowy2014checkcell} take a  more formalized approach which they label ``Data Debugging''.
Their solution uses statistical analysis to find values with an unusually high impact on the calculated results in a spreadsheet, as such values are likely either very important or erroneous.





\section{Discussion}
\label{sec:discussion}

Based on the research and results for smell detection in end-user programming domains, there are many directions for future work in the domains studied and other end-user domains.





\subsection{Threats to Validity}
The threats to validity of this work inherit the threats to validity of the original studies~\cite{Stolee2015, Stolee2011, StoleeTSE2013, Hermans2011, Hermans2012intra, Hermans2012inter, hermans2014bumblebee, badame2012refactoring} on end-user refactoring in spreadsheets and Yahoo! Pipes.

The three domains studied in this paper all happen to be dataflow languages, and the smells and refactorings may not generalize to other end-user programming domains (e.g., Scratch is OO-based). \todo{katie, would you say Kodu is dataflow based too?}


\todo{In Kodu, smells vs. design decisions}

\section{Concluding Remarks}
\label{sec:conclusions}
This paper presents an overview of the work in smell detection for end-user programming languages. More specifically, it synthesizes work on Yahoo!\ Pipes and Excel into a catalog of generally applicable smells in end-user languages. To demonstrate the applicability of the catalog, we apply it to two new domains: \ms~and Kodu, two visual languages aimed at programming education. The results show that indeed many of the catalog's smells apply in the new domains, and small abstractions, duplicate code and dead code occur in these educational languages too, while being of a quite different character than the textual languages aimed at professional developers that the smells were originally defined for. This shows the applicability of these smells, and also warrants further research into issues end-users encounter while programming. The contributions of this paper are:

\begin{itemize}
	\item A catalog of object-oriented-inspired code smells in end-user programs (Section \ref{sec:smells})
	\item Application of the catalog to two new end-user domains focused on education (Section \ref{sec:application})
	\item Identification of future opportunities for smell detection in end-user programming domains, both within and beyond the OO paradigm (Section \ref{sec:beyond})
\end{itemize}

The current work gives rise to more research, for example \todo{future work}

%sentence from the original intro, I think I like it better here, it feels reflecting
The applicability of smells, originally created to detect weaknesses in source code, to other domains shows how powerful the concept is. Furthermore, studying the smells in a fresh context provides new insight on how to use smells in software engineering and even suggests new types of smells. 

\balance

\section*{Acknowledgements}
Special thanks to Stephen Coy for his help with Kodu. This work is supported in part by  NSF SHF-EAGER-1446932 and the Harpole-Pentair endowment at Iowa State University.


\bibliographystyle{IEEEtran}
\bibliography{literaturelist}

\end{document}




