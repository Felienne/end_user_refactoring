\documentclass{sig-alternate}

%Deadline: April 8, 2015
%Call for papers: http://www.computer.org/web/computingnow/swcfp6

\usepackage{url}
\usepackage[table,xcdraw]{xcolor}
\usepackage{eurosym}
\usepackage{amsfonts}
\usepackage{balance}
\usepackage{cite} %this package is awesome - it reorders lists of citations to be in numeric order
\usepackage{pifont}
\usepackage{eqparbox}

% Tables
\usepackage{booktabs}
\usepackage{pbox}
\renewcommand{\arraystretch}{1.2} 
\usepackage{arydshln}
%\renewcommand*\cmidrule{} % No middle lines
%\renewcommand{\arraystretch}{1.5} % Additional spacing with no middle lines
%\renewcommand*\cmidrule{\hdashline[1pt/2pt]}% Dashed middle lines
\renewcommand*\cmidrule{\midrule[0.001em]} % Thin middle lines
%\renewcommand*\cmidrule{\midrule} % Thick middle lines

%Images
%\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

\hyphenation{second-ly ap-pen-dix}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ms}{LEGO MINDSTORMS EV3}
\newcommand{\mbs}{\textsc{my blocks}}
\newcommand{\mb}{\textsc{my block}}

\newcommand{\ignore}[1]{}

\begin{document}
%\bstctlcite{IEEEexample:BSTcontrol}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{A Catalog of OO-inspired End-User Smells, \\and an Application to \ms~and Kodu}
%\title{Perspectives on End-User Refactoring: Past, Present, and Future}

\numberofauthors{3}
\author{David Hoepelman, Katryn Stolee, Felienne Hermans}



\maketitle


\begin{abstract}
In the workforce today, millions of people program without degrees or professional training in software development. 
These end-user programmers write code to design hardware circuits, combine web information, and make business decisions. 
Software engineering research into refactoring has traditionally focused on professionally used object-oriented programming languages, yet other domains and languages also suffer from code smells in need of refactoring. 

\todo{Update this}
In this work, we explore recent research in three end-user domains and languages, spreadsheets in Microsoft Excel, web mashups in Yahoo!\ Pipes, and system design in National Instruments' LabVIEW. 
Through exploring the commonalities and differences among the domains, we
1)~show how these end-user domains benefit from prior research on refactoring object-oriented languages,
2)~discuss unique smell detection and refactoring opportunities for these domains, and
3)~identify future opportunities for smell detection and refactoring research in these studied domains as well as other end-user programming domains. 
\end{abstract}


\section{Introduction}
End-user programmers are said to outnumber  professional programmers three times over \cite{Scaf2005}.
These end-user programmers perform a wide variety of tasks within their organizations, ranging from building or maintaining applications to simple data manipulation in a spreadsheet.
While performing these tasks, end-user programmers face many of the challenges of professional developers, such as identifying faults, debugging, or understanding code written by someone else~\cite{Ko2011}.
Similar to code written by professional developers, end-user artifacts may have a long life-span, the average lifespan of a corporate spreadsheet being five years~\cite{Hermans2011}.
During this long lifespan, end-user artifacts are modified, often by different people.
These properties make them, like source code artifacts, vulnerable to \emph{smells}. 

Smells in end-user programming have been a topic of research over the past few years. Most notable are structural smells in Yahoo!\ Pipes web mashups~\cite{Stolee2011} and  Excel spreadsheets \cite{Hermans2012inter} Experiments in all these areas have shown that end-user programmers understand smells and often prefer versions of their code that are non-smelly \cite{Hermans2012intra, StoleeTSE2013, chambers2013smell}. Alleviating those smells can be achieved with refactoring.

Refactoring was first introduced as a systematic way to restructure source code and facilitate software evolution and maintenance. Martin Fowler later introduced the concept of code smells \cite{Fowl1999}. 
Refactoring code is often motivated by noticing a code smell, which signals the opportunity for improvement.

The taxonomy of smells outlined in Fowler's text pertained  to object-oriented (OO) code, and professional programming languages were the focus for at least the first decade of refactoring and code smell research~\cite{Mens:2004:SSR:972215.972286}.
Like smell definitions refactorings have too been adapted and extended to other 
end-user programming paradigms, including web mashups~\cite{Stolee2011, StoleeTSE2013}, Excel spreadsheets~\cite{Hermans2011, Hermans2012inter, hermans2014bumblebee}, and LabVIEW programs~\cite{chambers2013smell}.

Considering the large number of end-user programmers, the longevity of their artifacts and the preference for non-smelly code, supporting end-user programmers in code smell detection and refactoring is valuable.
The applicability of smells, originally created to detect weaknesses in source code, to other domains shows how powerful the concept is.
Furthermore, studying the smells and refactorings in a fresh context provides new insight on how to use smells in software engineering and  even suggests new types of smells.
The contributions of this work are:

\begin{itemize}
%	\item Synthesis of recent research in smell detection and refacotring for end-user programming languages
%	\item Motivation for the study of smells and refactoring for end-user programming languages based on empirical evidence
	\item Synthesis and catalog of object-oriented-inspired code smells  and refactoring in end-user programs
	\item Discussion of unique smell detection and refactoring opportunities in the end-user domains %Discussion of how smells and refactoring in  end-user domains may translate to professional languages
	\item Identification of future opportunities for smell detection and refactoring in end-user programming domains
\end{itemize}


\section{Background}
\label{sec:background}

In this section we briefly explore each end-user language targeted by prior refactoring research  before presenting the relevant code smells in  Section~\ref{sec:smells} and refactorings in Section~\ref{sec:refactoring}.

\paragraph{Excel}

\begin{figure}
\caption{Microsoft Excel 2013 showing a spreadsheet. Column B and C shows the typical mix of data and calculation. The formula of the selected cell B17 is visible right above the spreadsheet.}
\centering
\includegraphics[width=\columnwidth]{img/excel-2}
\label{fig:spreadsheetexample}
\end{figure}

Spreadsheets are very commonly used in businesses, from inventory administration to educational applications and from scientific modeling to financial systems.
Winston ~\cite{Wins2001} estimates that 90\% of all analysts in industry perform calculations in spreadsheets. 
Microsoft Excel is by far the most used, and therefore most studied, spreadsheet program, but other implementations exists and are similar.

In modern spreadsheet programs, a \textit{cell} can contain a single \textit{formula} which performs a calculation, and a table of cells is bundled in a \textit{worksheet}; an example is shown in Figure~\ref{fig:spreadsheetexample}. 
A \textit{workbook} consist of a collection of worksheets.
Formulas can reference other cells in the same or in different workbooks and worksheets.


\paragraph{Yahoo!\ Pipes}
Yahoo!\ Pipes is a popular web mashup language and environment with which RSS feed information can be collected and combined from various sources.  Figure~\ref{fig:ypexample} shows an example program. The boxes represent modules connected by wires. 
Abstraction is possible with \emph{subpipe} modules, which allow a programmer to insert a different pipe as a subroutine, appearing like a standard module. 

\begin{figure}
\caption{Example of a program in Yahoo!\ Pipes. It has five RSS feed data sources, each in a \emph{Fetch Feed} module, feeding to a \emph{Union} module that concatenates the feeds, a \emph{Truncate} module that limits the number of items to 15 prior to the final \emph{Pipe Output}. }
\centering
\includegraphics[width=\columnwidth]{img/yp-1}
\label{fig:ypexample}
\end{figure}


\section{Smells in end-user programs}
\label{sec:smells}
Research into end-user language smells has had two approaches, which are not mutually exclusive.
The first approach is to take existing smells for OO programming languages, usually those defined by Fowler~\cite{Fowl1999}, and transform them to be applicable to the end-user environment \cite{Hermans2012inter,Hermans2012intra,Stolee2011,StoleeTSE2013, chambers2013smell}.
The second approach is to define smells tailored to the end-user environment.
This can be done by interviewing experienced end-users to see which smells they perceive \cite{chambers2013smell}, by looking at user reports like forum or newsgroup posts~ \cite{badame2012refactoring,chambers2013smell}, or by analyzing publicly available repositories \cite{Stolee2011,StoleeTSE2013}.

This section provides an overview of different smells that researchers have found to be applicable to end-user artifacts using both the above described approaches and proposes future directions for smell detection in these domains. 

\begin{table*}
\caption{Code Smells in End-User Programs
\label{table:oosmellslarge}}
\centering
\sffamily
\begin{tabular} {@{}llll@{}}
\toprule
\textbf{OO Smell}
	& \textbf{Excel}
	& \textbf{Yahoo!\ Pipes}
\\ \midrule
Feature Envy
	& Feature Envy \cite{Hermans2012inter}
	& Feature Envy *
\\ \cmidrule
Long Method
	& Multiple Operations \cite{Hermans2012intra}
	& Long Module *
\\ \cmidrule
Message Chain
	& Long Calculation Chain \cite{Hermans2012intra}
	& 
\\ \cmidrule
Inappropriate Intimacy
	& Inappropriate Intimacy \cite{Hermans2012inter}
	& Inappropriate Intimacy *
\\ \cmidrule
Lazy class or Middle Man
	& Middle Man \cite{Hermans2012inter}
	& Unnecessary Abstraction \cite{StoleeTSE2013}
\\ \cmidrule
Many Parameters
	& Multiple References \cite{Hermans2012intra}
	& 
\\ \cmidrule
Duplicate Code
	& Duplicated Formulas \cite{Hermans2012intra}
	& Duplicate Modules, Duplicate String or
\\ % Continuation
& 
& Isomorphic Paths \cite{StoleeTSE2013}
\\ \cmidrule
Dead Code
	& ~\ding{55}
	& Disconnected or Dangling Modules \cite{StoleeTSE2013}
\\ \cmidrule
Unused Field
	& ~\ding{55}
	& Noisy Module \cite{StoleeTSE2013}
\\ \cmidrule
No-op
	& Redundant Operations *
	& Unnecessary Module \cite{StoleeTSE2013}
\\ \cmidrule
Use of Deprecated Interfaces
	& Deprecated Functions *
	& Deprecated Module or Invalid Source \cite{StoleeTSE2013}
\\ \bottomrule
\multicolumn{4}{c}{} \\
\multicolumn{4}{l}{\ding{55} : Not applicable due to the nature of the paradigm} \\
\multicolumn{4}{l}{* : Proposed smell, likely future opportunity not supported by prior work}\\
\multicolumn{4}{l}{$\langle$blank$\rangle$ : Not discussed in this work, possible future opportunity} \\
\multicolumn{4}{l}{\todo{fill all empty spots, they should either be explicitly NA or possible}} \\
\end{tabular}
\end{table*}



\subsection{OO Smells in End-User Programs}
\label{sec:smells:oo}
 We summarize the OO smells present in two end-user languages, Excel spreadsheets and Yahoo!\ Pipes mashups, in Table~\ref{table:oosmellslarge}.
 
 Overall, we often observe similarities in the code smells studied. For example, the \emph{Duplicate Code} smell has been studied in both languages.  Some smells, like the \emph{Long Method} smell, have been studied in only one domain but are likely applicable in the other domain, these are marked with *.  These smells present opportunities for future research, detailed in Section~\ref{subsec:futuresmells}.
 
 In this section we will detail the application of OO smells on specific end-user languages.
 
% A small number of smells are definitely not applicable (\ding{55}) because of differences in the domains. Spreadsheets, for example, cannot contain dead code because the user might still be interested in a piece of data even if it is not used anywhere else in the spreadsheet.

 \subsubsection{Excel}
Hermans et al. \cite{Hermans2012inter,Hermans2012intra} analogize a workbook to a program, a worksheet to a class inside that program and a cell to a method and use this to transform nine of Fowlers smells.
An example of this is the \emph{Long Method} smell, which translates to the \emph{Multiple Operations} smell because formulas with a large number of operations suffer from similar problems as long methods.

\subsubsection{Yahoo!\ Pipes}
Stolee and Elbaum~\cite{Stolee2011, StoleeTSE2013} treat a Yahoo!\ Pipes mashup as a class and each module as a method.  Fields in a module are treated as parameters. Using this analogy,  several OO smells were mapped to this language. The most common smell, appearing in nearly one-third of the 8,000 pipes studied, was \emph{Duplicate Strings}, an instance of Fowler's \emph{Duplicate Code} smell. 
\emph{Duplicate Modules}, impacted nearly one-quarter of the pipes studied. 
 Overall, 81\% of the programs studied from the Yahoo!\ Pipes community had at least one smell. 
 
Yahoo!\ can also \emph{deprecate modules}, which can create similar problems to using deprecated or old versions of interfaces.

\subsection{Future Opportunities for Smell Detection}
\label{subsec:futuresmells}
Although not all OO smells have been studied in both domains, this does not mean they are not applicable, just that they have not been studies before. This is indicated in Table \ref{table:oosmellslarge} with a *. For example, Feature Envy is not discussed in previous work on Yahoo! Pipes, but could apply when \todo{Katie, how exactly?}. Similarly, redundant operations could occur in Excel, in fact, they do. A formula like SUM(A1+A2+A3), that we have seen in practice, exhibits the No-Op smell. While the occurrence of these smells falls outside of the scope of the current work, in this section we discuss the potential of generalizing some of the OO and domain-specific smell definitions to additional domains, thus addressing all *'s in Table \ref{table:oosmellslarge}.

\subsubsection{Excel}
Most of the smells studied in other end-user domains have been studied in Excel spreadsheets, but there is some future potential in the areas of redundancy and deprecation.

Currently all research in smells and spreadsheets has focused on Microsoft Excel.
However, other spreadsheet software exists and operates on the same principles.
Thus there is an opportunity to confirm that the identified smells apply in other spreadsheet software.

\subsubsection{Yahoo!\ Pipes}
\label{sec:smells:future:yp}
%Many of the smells studied in Excel and LabVIEW could apply to Yahoo!\ Pipes, and in particular, \emph{Feature Envy} and \emph{Inappropriate Intimacy}. 
%uses methods of another class excessively - envy
The \emph{Feature Envy} smell could  apply when introducing abstraction. For example, if a pipe has several instances of the same subpipe module, this could be excessive use of another class. 

%depends on implementation of another class too much - intimacy
When a program uses too much abstraction relative to the size of the pipe, it could suffer from \emph{Inappropriate Intimacy} by depending too much on the implementation of the other class. In fact, in an empirical evaluation, programmers often preferred pipes without subpipe modules because they were easier to understand~\cite{StoleeTSE2013}. 

%long method
A \emph{Long Module} smell could apply when a module has a large number of fields. For example, the \emph{Fetch Feed} module, as in Figure~\ref{fig:ypexample}, can hold one or more URLs. When the number of URLs makes the method so big it does not fit on the screen, this would likely impact the understandability of the pipe. 

Drawing inspiration from the domain-specific \emph{Inconsistent Formula} smell in Excel, identifying program patterns that are close, but not exactly the same, could identify missed opportunities for abstraction or errors in the mashup structure. 





\section{Application}
In the above section, we have destilled a catalog of end-user smells from previous work on end-user smells. In order to demonstrate the applicability of our catalog, we apply it to a new domain: \ms software. 

\begin{figure}
\caption{The interface of \ms~showing a simple line following program.}
\centering
\includegraphics[width=\columnwidth]{img/ms}
\label{fig:ms}
\end{figure}

\subsection{\ms}
\ms is the third iteration of the LEGO MINDSTORMS robotics line. It consists of a number of sensors, four motors and a ARM 9 ``intelligent brick''. The robotics kit comes with a control software package, which allows for visual programming of the brick. The software supports several basic constructs common to programming, including loops and conditionals, but also more advanced features like parallel execution. Figure \ref{fig:ms} shows the user interface of the \ms~software with a program that makes the robot follow a black line, by steering left is the sensor value is too low and right if it is too high. 

In addition to the programming concepts described above, users have the ability to define `\mbs~' which basically are subroutines. \mbs~ may have up to 9 different input and one output parameter. \mbs~ cannot be created from scratch; they can only be created by selecting blocks in an existing program and creating a new block for them, together with a call to the newly created block, an action extremely similar to `extract method' present in most modern IDEs. \todo{can programs share the \mbs, have to look into that}

\subsection{Smells and refactorings in \ms }
In this subsection we describe how the smells would apply to \ms programs. As common in the other approaches, we define a loose mapping of OO concepts to the end-user language in question to be able to translate the smells. In \ms~ programming, there are  \emph{\mbs~} that contain a number of blocks, can be used multiple times and can use input and output. As such they resemble methods in source code, modules in Yahoo! Pipes and worksheets in spreadsheets. Based on this translation, we investigate whether OO smells could occur in \ms~programs too. 

\begin{description}
\item[Feature envy] While all defined variables within \ms~ are global, they can be written in a certain \mb~ but read in a different one. If in a given \mb~ many variables are read that have been written somewhere else, this might be an occurrence of the feature envy smell. 
\item[Long method] If a \mb~ grows very large, it will no longer be easy to understand, diminishing the added value.
\item[Inappropriate Intimacy] As described above, variables might be read in one \mb~but written somewhere else. If there are two \mbs~sharing multiple variables this way, it might be better to combine them.
\item[Lazy Class] If a \mb~ is very small, for example, consisting of just one block, they do not add a lot of value, while making the program harder to understand, as a user has to navigate to the \mb~ to see what its function is.
\item[Message Chain] Because \mbs~can have both input and output parameters, it is possible that they created a message chain in which values are continuously passed until they are used, while they could have been passed outside of the \mbs~.
\item[Many Parameters] \mbs~ can have 9 different parameters, which could be considered too much for easy understandability.
\item[Duplicate Code] If the same, or very similar combinations of blocks occur, this would be the duplicate code smell.
\item[Dead Code] It is possible for programming blocks to be disconnected, but the interface clearly indicates this by making them gray. However, unused \mbs~ can be present in the project without a warning being issued. This is smelly as it makes the program unnecessarily large.
\item[Unused Field] As explained above, \mbs~can define parameters. However, the user is not forced to use them, hence it is possible to define more parameters than used.
\item[No-op] It is possible to combine blocks in such a fashion that they do not actually contribute to the functionality of the program. For example, it a user stops the same motor twice, the second stop will be a no-op.
\item[Use of Deprecated Interfaces] This is a smell that does not apply, as, to date, there is only one version of the \ms~software and no blocks have been depreciated.
\end{description}

\subsection{Study context}
One of the authors of this paper runs a robotics club for kids where kids aged 8 to 13 program robots every week. Their programs have been collected as dataset for this paper. More specifically, we focus on two different projects within this set, RoboCup and Sumo. These two types of programs related to two different \ms~competitions: Sumo is a simple robot game in which robots have to `sumo wrestle' each other: the robot that gets pushed out of the circular competition area first loses\footnote{\url{http://www.sugobot.com/}}. The Robocup programs were made to participate in the RoboCup Junior Rescue challenge\footnote{\url{http://rcj.robocup.org/rescue.html}}, where robots have to first navigate part of the field by following a line and then look for a soda can and push it out of the field.

\subsection{Findings}
When investigating the programs, we found that they indeed sometimes suffered from smells. Table \ref{tab:robotica} presents an overview of the smells.

\subsubsection{Duplicate Code}
The most common smell we found in the nine programs is the Duplicate Code smell, which six out of nine program suffer from.

\subsubsection{Dead Code}
The second most common smell is Dead Code. In five out of nine programs we found \mbs~ no longer connected to the main program. This can pose a problem, as the EV3 environment compiles and transfers all programs and \mbs~to the brick, causing the memory to be full quite quickly.

Looking at the \ms~interface, it is not that surprising that users forget about disconnected \mbs. The interface does not help users in understanding what blocks are used. If we look at the project properties screen, shown in Figure \ref{fig:overview}, one can see that there is no information about which \mb~is used where. Even worse, we can delete connected \mbs without getting a warning, after which the program no longer compiles.

\begin{table*}[]
\centering

\caption{Overview of the seventeen \ms~programs and the smells they exhibit}
\label{tab:robotica}
\sffamily
\begin{tabular}{llllll|lll|lllllllll}
Name & L1  & L2 & L3  & L4  & L5  & L6  & L7  & L8  & L9  & L10 & L11 & L12 & L13 & L14 & L15 & L16 & L17 \\
Feature Envy                                           & \ding{51} &  & \ding{51} & \ding{51} &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Long method                                            &   &  &   &   & \ding{51} &   &   &   &   & \ding{51} &   &   &   & \ding{51} &   &   & \ding{51}   \\
Inappropriate Intimacy                                 &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Lazy Class                                             & \ding{51} &  & \ding{51} & \ding{51} &   & \ding{51} &   &   &   &   &   &   &   &   &   &   &   \\
Message Chain                                          &   &  &   &   &   &   &   &   &   &   &   &   &   &   &   &   &   \\
Many Parameters                                        &   &  &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &   &   &   \\
Duplicate Code                                         &   &  &   & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} &   & \ding{51} &   &   & \ding{51} & \ding{51} \\
Dead Code                                              & \ding{51} &  & \ding{51} & \ding{51} &   &   & \ding{51} & \ding{51} &   &   &   &   &   & \ding{51} &   &   & \ding{51} \\
Unused Field                                           &   &  &   & \ding{51} &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &   \\
No-op                                                  &   &  & \ding{51} &   &   &   &   &   &   &   &   &   &   & \ding{51} &   &   &  
\end{tabular}
\end{table*}





\subsubsection{Lazy Class}
Lazy classes, which we counted as \mbs~having three or fewer blocks in them, are also common. Many of `lazy \mbs'~were relatively small, consisting of two or three blocks, or even 1 in some cases. You could say this is smelly, as understanding the \mb~ requires clicking it and that might not be worth it for small \mbs~. However, the \ms~interface does not allow regular blocks to be named, but it does allow this for \mbs. So by making a \mb, users can express the intent of a block. As an example, consider the two blocks shown in Figure 5, where the above a regular block moving a motor, and the second is a call to a \mb~with the same functionality. The first one just expresses what the robot must do, but the second one expresses the intent (`weg' meaning flee). By using the \mb, even with one block, the program gets easier to read.


\begin{figure}
\caption{Two blocks representing the same functionality, one in a regular block and one using a \mb.}
\centering
\includegraphics[width=3cm]{img/weg}
\label{fig:weg}
\end{figure}




\begin{figure}
\caption{The project properties screen for the Sumo program 1, showing the three \mbs~, but not indicating the \mb~ `draaien' is currently not called from the main program.}
\centering
\includegraphics[width=\columnwidth]{img/overview}
\label{fig:overview}
\end{figure}

\section{Related Work}

\label{sec:related_work}
This paper builds upon the extensive body of work related to code smells and refactoring in the end-user programming domain~\cite{Stolee2015, Stolee2011, StoleeTSE2013, Hermans2011, Hermans2012intra, Hermans2012inter, hermans2014bumblebee, chambers2013smell, chambers2015impact}. For an extensive overview in object-oriented research, we refer the reader to the work of Mens and Tourw\'{e} \cite{mens2004survey}.

\subsection{Smells based on user input}
\label{subsec:related_datasmells}
In end-user programming environments user input and logic are often more closely linked than they are in general purpose languages.
As such analyzing the input data as opposed to the logic can also be used to detect problems.

Cunha et. al \cite{cunha2012towards} claim to define code smells for spreadsheet, but for most of their smells they look at  anomalies in the data and define these as smells.
Examples of this are \textit{Standard Deviation} which occurs if one assumes a normal distribution for a column in numeric values and the column contains values which fall outside two standard deviations.
In more recent work, Barowy et. Al \cite{barowy2014checkcell} take a  more formalized approach which they label ``Data Debugging''.
Their solution uses statistical analysis to find values with an unusually high impact on the calculated results in a spreadsheet, as such values are likely either very important or erroneous.

\section{Discussion}
\label{sec:discussion}

Based on the research and results for smell detection and refactoring in end-user programming domains, there are many directions for future work in the domains studied and other end-user domains.

\subsection{Future Opportunities in Other Domains}
End-user programming domains extend beyond spreadsheets, web mashups, and system designs.
Stolee and Elbaum explore future opportunities for refactoring in educational programming languages~\cite{StoleeTSE2013}.
Additional opportunities in educational languages exist in LEGO Mindstorms, which is based off the G language for LabVIEW, or in MAX/MSP, which are visual programming languages for music and multimedia.
Other end-user programming domains that could benefit from smell analysis and refactoring are mathematical environments like MATLAB, Sage, and Mathematica.

In particular, the smells related to duplication and poor construction like \emph{Long Method}, \emph{Many Parameters} and \emph{Dead Code} are prevalent in the three domains studied.
These smells -- and their respective refactorings -- likely exist in other end-user programming domains, and likely hinder the understandability and maintainability of those programs.
Worse even, these smells could lead to errors, and thus these smells are worthy of our attention. 

%\subsection{Related Work}
%This paper builds upon the extensive body of work related to code smells and refactoring in the end-user programming domain~\cite{Stolee2015, Stolee2011, StoleeTSE2013, Hermans2011, Hermans2012intra, Hermans2012inter, hermans2014bumblebee, chambers2013smell, chambers2015impact}. For an extensive overview in object-oriented research, we refer the reader to the work of Mens and Tourw\'{e} \cite{mens2004survey}.

%\subsection{Future Opportunities in Professional Languages}
%In end-user programming languages, it has been shown that code smells impact the understandability of
%source code~\cite{StoleeTSE2013}. Additionally, being presented with code smells can motivate end-user programmers to improve their code~\cite{chambers2013smell}, and smells in spreadsheets have even been known to reveal actual errors~\cite{Hermans2012intra}. These lessons could extend to professional programming languages. but further study is needed. 
% outside of the end-user programming domains. 
%There has been successful in using automating smell detection, for example, during agile development (e.g.,~\cite{Schumacher:2010:BES:1852786.1852797}). Paired with the end-user evidence, a stronger case can be made to integrate automated smell detection in many domains. 

%\todo{Other data flow languages could benefit from \emph{normalize order of operations} to improve understandability (as it does with YP). }

\subsection{Threats to Validity}
The threats to validity of this work inherit the threats to validity of the original studies~\cite{Stolee2015, Stolee2011, StoleeTSE2013, Hermans2011, Hermans2012intra, Hermans2012inter, hermans2014bumblebee, chambers2013smell, chambers2015impact, badame2012refactoring}.

The three domains studied in this paper all happen to be dataflow languages, and the smells and refactorings may not generalize to other end-user programming domains (e.g., Scratch is OO-based). 

In addition, we note that the authors of this work have pioneered smell detection and refactoring research in spreadsheets and Yahoo!\ Pipes, but are not involved with LabVIEW. Thus, the opportunities for future work in this area may not be complete.  

\section{Concluding Remarks}
\label{sec:conclusions}
This paper presents an overview of the work in smell detection and refactoring for end-user programming languages. More specifically, it synthesizes work on Yahoo!\ Pipes, Excel and LabView. We explore commonalities between these works and identify opportunities for application to other end-user programming domains. As we move forward, we see many opportunities to explore additional smells and refactorings in the domains studied, in other end-user programming domains, and even in extending the findings to professional languages. 

\section{Future Work}
\subsection{Domain-Specific Smells}
\label{sec:smells:domain}
The end-user programming environments offer many opportunities to define smells based on user behavior or unique elements of the domain.
In this section, we explore opportunities for new smells in end-user domains that extend beyond the OO-inspired smells in Section~\ref{sec:smells:oo}. 

\subsubsection{Excel}

In spreadsheets data is often processed by having each record in a row and having a column with identical formulas to perform some calculation.
This leads to the definition of the \emph{Inconsistent Formula} smell, which occurs if a single, or small number, of cells contain a different formula while its neighbors or other cells in the row or column contain an identical formula.
Interestingly this smell is already detected by Microsoft Excel which warns the user about it.

Another smell specific to spreadsheets is when a formula references an empty cell, which is often in error \cite{cunha2012towards}.
This is comparable to a null pointer in other languages and would be a runtime error, but because a spreadsheet contains both the input data and logic we can directly mark it as a smell.

\subsubsection{Yahoo!\ Pipes}
%Talk about smells unique to the domain
By exploring a large subset of the Yahoo!\ Pipes repository, Stolee and Elbaum identified a smell based on the presence of broken data sources~\cite{StoleeTSE2013}.
A reference to a broken data sources  is similar to opening a non-existing file, which would be a runtime exception or error in most professional languages.
Such exceptions are not in the Yahoo!\ Pipes language, which is the reason to mark it as a smell. 
%Talk about deriving smells from the community
Similar exploration was used to  identify common programming practices, marking deviations from those practices as smells. 
This is similar to identifying  smells  as anti-patterns  and could be extended to any language. 

\balance

\section*{Acknowledgements}
This work is supported in part by  NSF SHF-EAGER-1446932 and the Harpole-Pentair endowment at Iowa State University.


\bibliographystyle{IEEEtran}
\bibliography{literaturelist}

\end{document}


